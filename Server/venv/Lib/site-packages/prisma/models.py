# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    email: _str
    password: _str
    role: 'enums.UserRole'
    tournamentsCreated: Optional[List['models.Tournament']] = None
    matchesRefereed: Optional[List['models.Match']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class Tournament(bases.BaseTournament):
    """Represents a Tournament record"""

    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    location: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    description: Optional[_str] = None
    createdById: Optional[_int] = None
    createdBy: Optional['models.User'] = None
    categories: Optional[List['models.Category']] = None
    courts: Optional[List['models.Court']] = None
    participants: Optional[List['models.Participant']] = None
    teams: Optional[List['models.Team']] = None
    matches: Optional[List['models.Match']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TournamentKeys']] = None,
        exclude: Optional[Iterable['types.TournamentKeys']] = None,
        required: Optional[Iterable['types.TournamentKeys']] = None,
        optional: Optional[Iterable['types.TournamentKeys']] = None,
        relations: Optional[Mapping['types.TournamentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TournamentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Tournament_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Tournament_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Tournament_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Tournament_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Tournament_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Tournament_relational_fields:
                        raise errors.UnknownRelationalFieldError('Tournament', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Tournament / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Tournament',
            }
        )
        _created_partial_types.add(name)


class Category(bases.BaseCategory):
    """Represents a Category record"""

    id: _int
    name: _str
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: _int
    maxAge: _int
    tournamentId: _int
    tournament: Optional['models.Tournament'] = None
    participants: Optional[List['models.Participant']] = None
    teams: Optional[List['models.Team']] = None
    matches: Optional[List['models.Match']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CategoryKeys']] = None,
        exclude: Optional[Iterable['types.CategoryKeys']] = None,
        required: Optional[Iterable['types.CategoryKeys']] = None,
        optional: Optional[Iterable['types.CategoryKeys']] = None,
        relations: Optional[Mapping['types.CategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Category_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Category_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Category_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Category_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Category_relational_fields:
                        raise errors.UnknownRelationalFieldError('Category', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Category / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Category',
            }
        )
        _created_partial_types.add(name)


class Participant(bases.BaseParticipant):
    """Represents a Participant record"""

    id: _int
    fullName: _str
    birthDate: datetime.datetime
    gender: 'enums.Gender'
    email: Optional[_str] = None
    phone: Optional[_str] = None
    isActive: _bool
    tournamentId: _int
    tournament: Optional['models.Tournament'] = None
    categoryId: Optional[_int] = None
    category: Optional['models.Category'] = None
    teamLinks: Optional[List['models.TeamParticipant']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ParticipantKeys']] = None,
        exclude: Optional[Iterable['types.ParticipantKeys']] = None,
        required: Optional[Iterable['types.ParticipantKeys']] = None,
        optional: Optional[Iterable['types.ParticipantKeys']] = None,
        relations: Optional[Mapping['types.ParticipantRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ParticipantKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Participant_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Participant_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Participant_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Participant_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Participant_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Participant_relational_fields:
                        raise errors.UnknownRelationalFieldError('Participant', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Participant / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Participant',
            }
        )
        _created_partial_types.add(name)


class Team(bases.BaseTeam):
    """Represents a Team record"""

    id: _int
    name: _str
    tournamentId: _int
    tournament: Optional['models.Tournament'] = None
    categoryId: _int
    category: Optional['models.Category'] = None
    players: Optional[List['models.TeamParticipant']] = None
    homeMatches: Optional[List['models.Match']] = None
    awayMatches: Optional[List['models.Match']] = None
    winnerOf: Optional[List['models.Match']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TeamKeys']] = None,
        exclude: Optional[Iterable['types.TeamKeys']] = None,
        required: Optional[Iterable['types.TeamKeys']] = None,
        optional: Optional[Iterable['types.TeamKeys']] = None,
        relations: Optional[Mapping['types.TeamRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TeamKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Team_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Team_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Team_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Team_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Team_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Team_relational_fields:
                        raise errors.UnknownRelationalFieldError('Team', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Team / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Team',
            }
        )
        _created_partial_types.add(name)


class TeamParticipant(bases.BaseTeamParticipant):
    """Represents a TeamParticipant record"""

    id: _int
    teamId: _int
    participantId: _int
    team: Optional['models.Team'] = None
    participant: Optional['models.Participant'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TeamParticipantKeys']] = None,
        exclude: Optional[Iterable['types.TeamParticipantKeys']] = None,
        required: Optional[Iterable['types.TeamParticipantKeys']] = None,
        optional: Optional[Iterable['types.TeamParticipantKeys']] = None,
        relations: Optional[Mapping['types.TeamParticipantRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TeamParticipantKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TeamParticipant_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TeamParticipant_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TeamParticipant_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TeamParticipant_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TeamParticipant_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TeamParticipant_relational_fields:
                        raise errors.UnknownRelationalFieldError('TeamParticipant', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TeamParticipant / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TeamParticipant',
            }
        )
        _created_partial_types.add(name)


class Court(bases.BaseCourt):
    """Represents a Court record"""

    id: _int
    name: _str
    locationNote: Optional[_str] = None
    tournamentId: _int
    tournament: Optional['models.Tournament'] = None
    matches: Optional[List['models.Match']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CourtKeys']] = None,
        exclude: Optional[Iterable['types.CourtKeys']] = None,
        required: Optional[Iterable['types.CourtKeys']] = None,
        optional: Optional[Iterable['types.CourtKeys']] = None,
        relations: Optional[Mapping['types.CourtRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CourtKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Court_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Court_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Court_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Court_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Court_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Court_relational_fields:
                        raise errors.UnknownRelationalFieldError('Court', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Court / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Court',
            }
        )
        _created_partial_types.add(name)


class Match(bases.BaseMatch):
    """Represents a Match record"""

    id: _int
    round: _int
    groupCode: Optional[_str] = None
    scheduledAt: Optional[datetime.datetime] = None
    startedAt: Optional[datetime.datetime] = None
    finishedAt: Optional[datetime.datetime] = None
    status: 'enums.MatchStatus'
    homeScore: Optional[_int] = None
    awayScore: Optional[_int] = None
    tournamentId: _int
    tournament: Optional['models.Tournament'] = None
    categoryId: _int
    category: Optional['models.Category'] = None
    courtId: Optional[_int] = None
    court: Optional['models.Court'] = None
    homeTeamId: _int
    homeTeam: Optional['models.Team'] = None
    awayTeamId: _int
    awayTeam: Optional['models.Team'] = None
    winnerTeamId: Optional[_int] = None
    winnerTeam: Optional['models.Team'] = None
    refereeId: Optional[_int] = None
    referee: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MatchKeys']] = None,
        exclude: Optional[Iterable['types.MatchKeys']] = None,
        required: Optional[Iterable['types.MatchKeys']] = None,
        optional: Optional[Iterable['types.MatchKeys']] = None,
        relations: Optional[Mapping['types.MatchRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MatchKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Match_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Match_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Match_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Match_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Match_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Match_relational_fields:
                        raise errors.UnknownRelationalFieldError('Match', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Match / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Match',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'tournamentsCreated',
        'matchesRefereed',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournamentsCreated', {
            'name': 'tournamentsCreated',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Tournament\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('matchesRefereed', {
            'name': 'matchesRefereed',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Tournament_relational_fields: Set[str] = {
        'createdBy',
        'categories',
        'courts',
        'participants',
        'teams',
        'matches',
    }
_Tournament_fields: Dict['types.TournamentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('location', {
            'name': 'location',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('startDate', {
            'name': 'startDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endDate', {
            'name': 'endDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdById', {
            'name': 'createdById',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('categories', {
            'name': 'categories',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Category\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('courts', {
            'name': 'courts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Court\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('participants', {
            'name': 'participants',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Participant\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Team\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('matches', {
            'name': 'matches',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Category_relational_fields: Set[str] = {
        'tournament',
        'participants',
        'teams',
        'matches',
    }
_Category_fields: Dict['types.CategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('gender', {
            'name': 'gender',
            'is_list': False,
            'optional': False,
            'type': 'enums.Gender',
            'is_relational': False,
            'documentation': None,
        }),
        ('level', {
            'name': 'level',
            'is_list': False,
            'optional': False,
            'type': 'enums.Level',
            'is_relational': False,
            'documentation': None,
        }),
        ('minAge', {
            'name': 'minAge',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('maxAge', {
            'name': 'maxAge',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournamentId', {
            'name': 'tournamentId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournament', {
            'name': 'tournament',
            'is_list': False,
            'optional': True,
            'type': 'models.Tournament',
            'is_relational': True,
            'documentation': None,
        }),
        ('participants', {
            'name': 'participants',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Participant\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('teams', {
            'name': 'teams',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Team\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('matches', {
            'name': 'matches',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Participant_relational_fields: Set[str] = {
        'tournament',
        'category',
        'teamLinks',
    }
_Participant_fields: Dict['types.ParticipantKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fullName', {
            'name': 'fullName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birthDate', {
            'name': 'birthDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('gender', {
            'name': 'gender',
            'is_list': False,
            'optional': False,
            'type': 'enums.Gender',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone', {
            'name': 'phone',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournamentId', {
            'name': 'tournamentId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournament', {
            'name': 'tournament',
            'is_list': False,
            'optional': True,
            'type': 'models.Tournament',
            'is_relational': True,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.Category',
            'is_relational': True,
            'documentation': None,
        }),
        ('teamLinks', {
            'name': 'teamLinks',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TeamParticipant\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Team_relational_fields: Set[str] = {
        'tournament',
        'category',
        'players',
        'homeMatches',
        'awayMatches',
        'winnerOf',
    }
_Team_fields: Dict['types.TeamKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournamentId', {
            'name': 'tournamentId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournament', {
            'name': 'tournament',
            'is_list': False,
            'optional': True,
            'type': 'models.Tournament',
            'is_relational': True,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.Category',
            'is_relational': True,
            'documentation': None,
        }),
        ('players', {
            'name': 'players',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TeamParticipant\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('homeMatches', {
            'name': 'homeMatches',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('awayMatches', {
            'name': 'awayMatches',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('winnerOf', {
            'name': 'winnerOf',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_TeamParticipant_relational_fields: Set[str] = {
        'team',
        'participant',
    }
_TeamParticipant_fields: Dict['types.TeamParticipantKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('teamId', {
            'name': 'teamId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('participantId', {
            'name': 'participantId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('team', {
            'name': 'team',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
        ('participant', {
            'name': 'participant',
            'is_list': False,
            'optional': True,
            'type': 'models.Participant',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Court_relational_fields: Set[str] = {
        'tournament',
        'matches',
    }
_Court_fields: Dict['types.CourtKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('locationNote', {
            'name': 'locationNote',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournamentId', {
            'name': 'tournamentId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournament', {
            'name': 'tournament',
            'is_list': False,
            'optional': True,
            'type': 'models.Tournament',
            'is_relational': True,
            'documentation': None,
        }),
        ('matches', {
            'name': 'matches',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Match\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Match_relational_fields: Set[str] = {
        'tournament',
        'category',
        'court',
        'homeTeam',
        'awayTeam',
        'winnerTeam',
        'referee',
    }
_Match_fields: Dict['types.MatchKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('round', {
            'name': 'round',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('groupCode', {
            'name': 'groupCode',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledAt', {
            'name': 'scheduledAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('startedAt', {
            'name': 'startedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('finishedAt', {
            'name': 'finishedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.MatchStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('homeScore', {
            'name': 'homeScore',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('awayScore', {
            'name': 'awayScore',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournamentId', {
            'name': 'tournamentId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tournament', {
            'name': 'tournament',
            'is_list': False,
            'optional': True,
            'type': 'models.Tournament',
            'is_relational': True,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.Category',
            'is_relational': True,
            'documentation': None,
        }),
        ('courtId', {
            'name': 'courtId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('court', {
            'name': 'court',
            'is_list': False,
            'optional': True,
            'type': 'models.Court',
            'is_relational': True,
            'documentation': None,
        }),
        ('homeTeamId', {
            'name': 'homeTeamId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('homeTeam', {
            'name': 'homeTeam',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
        ('awayTeamId', {
            'name': 'awayTeamId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('awayTeam', {
            'name': 'awayTeam',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
        ('winnerTeamId', {
            'name': 'winnerTeamId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('winnerTeam', {
            'name': 'winnerTeam',
            'is_list': False,
            'optional': True,
            'type': 'models.Team',
            'is_relational': True,
            'documentation': None,
        }),
        ('refereeId', {
            'name': 'refereeId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('referee', {
            'name': 'referee',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(Tournament)
model_rebuild(Category)
model_rebuild(Participant)
model_rebuild(Team)
model_rebuild(TeamParticipant)
model_rebuild(Court)
model_rebuild(Match)
