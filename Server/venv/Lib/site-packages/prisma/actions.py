# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = User.prisma().query_first(
            'SELECT * FROM User WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = User.prisma().create(
            data={
                # data to create a User record
                'name': 'dhheabfhf',
                'email': 'ggciceaie',
                'password': 'bbehjachib',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'name': 'cadfabfehe',
                    'email': 'dgiiaaijj',
                    'password': 'bfaiacjjfc',
                },
                {
                    # data to create a User record
                    'name': 'eigcfgbif',
                    'email': 'bagcfbhiig',
                    'password': 'cghideieh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().delete(
            where={
                'id': 180171308,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().find_unique(
            where={
                'id': 836760821,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().find_unique_or_raise(
            where={
                'id': 595337866,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the updatedAt field
        users = User.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the name field
        user = User.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the email field
        user = User.prisma().find_first_or_raise(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = User.prisma().update(
            where={
                'id': 790425851,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = User.prisma().upsert(
            where={
                'id': 2111915288,
            },
            data={
                'create': {
                    'id': 2111915288,
                    'name': 'eigcfgbif',
                    'email': 'bagcfbhiig',
                    'password': 'cghideieh',
                },
                'update': {
                    'name': 'eigcfgbif',
                    'email': 'bagcfbhiig',
                    'password': 'cghideieh',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = User.prisma().update_many(
            data={
                'password': 'bbejhfidcb'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = User.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = User.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = User.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by createdAt values
        # and count how many records are in each group
        results = User.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TournamentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tournament]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Tournament.prisma().query_raw(
            'SELECT * FROM Tournament WHERE id = $1',
            1644289366,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tournament
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Tournament.prisma().query_first(
            'SELECT * FROM Tournament WHERE createdAt = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TournamentCreateInput,
        include: Optional[types.TournamentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tournament record.

        Parameters
        ----------
        data
            Tournament record data
        include
            Specifies which relations should be loaded on the returned Tournament model

        Returns
        -------
        prisma.models.Tournament
            The created Tournament record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tournament record from just the required fields
        tournament = Tournament.prisma().create(
            data={
                # data to create a Tournament record
                'name': 'bdiicjafbj',
                'location': 'bgehebiafc',
                'startDate': datetime.datetime.utcnow(),
                'endDate': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.TournamentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tournament records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tournament record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Tournament.prisma().create_many(
            data=[
                {
                    # data to create a Tournament record
                    'name': 'bghffegacj',
                    'location': 'bhghchehcc',
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Tournament record
                    'name': 'dcgchcbbf',
                    'location': 'bdedcabahc',
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TournamentWhereUniqueInput,
        include: Optional[types.TournamentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tournament record.

        Parameters
        ----------
        where
            Tournament filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tournament model

        Returns
        -------
        prisma.models.Tournament
            The deleted Tournament record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tournament = Tournament.prisma().delete(
            where={
                'id': 675780521,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.TournamentWhereUniqueInput,
        include: Optional[types.TournamentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tournament record.

        Parameters
        ----------
        where
            Tournament filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tournament model

        Returns
        -------
        prisma.models.Tournament
            The found Tournament record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tournament = Tournament.prisma().find_unique(
            where={
                'id': 744964398,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.TournamentWhereUniqueInput,
        include: Optional[types.TournamentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tournament record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tournament filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tournament model

        Returns
        -------
        prisma.models.Tournament
            The found Tournament record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tournament = Tournament.prisma().find_unique_or_raise(
            where={
                'id': 1969681615,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TournamentWhereInput] = None,
        cursor: Optional[types.TournamentWhereUniqueInput] = None,
        include: Optional[types.TournamentInclude] = None,
        order: Optional[Union[types.TournamentOrderByInput, List[types.TournamentOrderByInput]]] = None,
        distinct: Optional[List[types.TournamentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tournament records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tournament records returned
        skip
            Ignore the first N results
        where
            Tournament filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tournament model
        order
            Order the returned Tournament records by any field
        distinct
            Filter Tournament records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tournament]
            The list of all Tournament records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tournament records
        tournaments = Tournament.prisma().find_many(take=10)

        # find the first 5 Tournament records ordered by the updatedAt field
        tournaments = Tournament.prisma().find_many(
            take=5,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TournamentWhereInput] = None,
        cursor: Optional[types.TournamentWhereUniqueInput] = None,
        include: Optional[types.TournamentInclude] = None,
        order: Optional[Union[types.TournamentOrderByInput, List[types.TournamentOrderByInput]]] = None,
        distinct: Optional[List[types.TournamentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tournament record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tournament filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tournament model
        order
            Order the returned Tournament records by any field
        distinct
            Filter Tournament records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tournament
            The first Tournament record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tournament record ordered by the name field
        tournament = Tournament.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TournamentWhereInput] = None,
        cursor: Optional[types.TournamentWhereUniqueInput] = None,
        include: Optional[types.TournamentInclude] = None,
        order: Optional[Union[types.TournamentOrderByInput, List[types.TournamentOrderByInput]]] = None,
        distinct: Optional[List[types.TournamentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tournament record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tournament filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tournament model
        order
            Order the returned Tournament records by any field
        distinct
            Filter Tournament records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tournament
            The first Tournament record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tournament record ordered by the location field
        tournament = Tournament.prisma().find_first_or_raise(
            skip=1,
            order={
                'location': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.TournamentUpdateInput,
        where: types.TournamentWhereUniqueInput,
        include: Optional[types.TournamentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tournament record.

        Parameters
        ----------
        data
            Tournament record data specifying what to update
        where
            Tournament filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tournament model

        Returns
        -------
        prisma.models.Tournament
            The updated Tournament record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tournament = Tournament.prisma().update(
            where={
                'id': 1116175964,
            },
            data={
                # data to update the Tournament record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.TournamentWhereUniqueInput,
        data: types.TournamentUpsertInput,
        include: Optional[types.TournamentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tournament filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tournament model

        Returns
        -------
        prisma.models.Tournament
            The created or updated Tournament record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tournament = Tournament.prisma().upsert(
            where={
                'id': 861472101,
            },
            data={
                'create': {
                    'id': 861472101,
                    'name': 'dcgchcbbf',
                    'location': 'bdedcabahc',
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                },
                'update': {
                    'name': 'dcgchcbbf',
                    'location': 'bdedcabahc',
                    'startDate': datetime.datetime.utcnow(),
                    'endDate': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.TournamentUpdateManyMutationInput,
        where: types.TournamentWhereInput,
    ) -> int:
        """Update multiple Tournament records

        Parameters
        ----------
        data
            Tournament data to update the selected Tournament records to
        where
            Filter to select the Tournament records to update

        Returns
        -------
        int
            The total number of Tournament records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tournament records
        total = Tournament.prisma().update_many(
            data={
                'startDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TournamentWhereInput] = None,
        cursor: Optional[types.TournamentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tournament records present in the database

        Parameters
        ----------
        select
            Select the Tournament fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tournament filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TournamentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Tournament.prisma().count()

        # results: prisma.types.TournamentCountAggregateOutput
        results = Tournament.prisma().count(
            select={
                '_all': True,
                'endDate': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TournamentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TournamentWhereInput] = None,
        cursor: Optional[types.TournamentWhereUniqueInput] = None,
    ) -> types.TournamentCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TournamentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TournamentWhereInput] = None,
        cursor: Optional[types.TournamentWhereUniqueInput] = None,
    ) -> Union[int, types.TournamentCountAggregateOutput]:
        """Count the number of Tournament records present in the database

        Parameters
        ----------
        select
            Select the Tournament fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tournament filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TournamentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Tournament.prisma().count()

        # results: prisma.types.TournamentCountAggregateOutput
        results = Tournament.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TournamentCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TournamentWhereInput] = None
    ) -> int:
        """Delete multiple Tournament records.

        Parameters
        ----------
        where
            Optional Tournament filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tournament records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tournament records
        total = Tournament.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TournamentScalarFieldKeys'],
        *,
        where: Optional['types.TournamentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TournamentAvgAggregateInput'] = None,
        sum: Optional['types.TournamentSumAggregateInput'] = None,
        min: Optional['types.TournamentMinAggregateInput'] = None,
        max: Optional['types.TournamentMaxAggregateInput'] = None,
        having: Optional['types.TournamentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TournamentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TournamentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TournamentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TournamentGroupByOutput']:
        """Group Tournament records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tournament fields to group records by
        where
            Tournament filter to select records
        take
            Limit the maximum number of Tournament records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TournamentGroupByOutput]
            A list of dictionaries representing the Tournament record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tournament records by createdById values
        # and count how many records are in each group
        results = Tournament.prisma().group_by(
            ['createdById'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Category]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Category.prisma().query_raw(
            'SELECT * FROM Category WHERE id = $1',
            1303003706,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Category
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Category.prisma().query_first(
            'SELECT * FROM Category WHERE name = $1',
            'bgiggdidbf',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CategoryCreateInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new Category record.

        Parameters
        ----------
        data
            Category record data
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created Category record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Category record from just the required fields
        category = Category.prisma().create(
            data={
                # data to create a Category record
                'name': 'caaaedabfc',
                'gender': enums.Gender.MALE,
                'level': enums.Level.BEGINNER,
                'minAge': 1868141281,
                'maxAge': 1860847622,
                'tournamentId': 1448521415,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.CategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Category records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Category record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Category.prisma().create_many(
            data=[
                {
                    # data to create a Category record
                    'name': 'bgcigfahea',
                    'gender': enums.Gender.MALE,
                    'level': enums.Level.BEGINNER,
                    'minAge': 1249606685,
                    'maxAge': 835903122,
                    'tournamentId': 763719779,
                },
                {
                    # data to create a Category record
                    'name': 'ecjjjfbae',
                    'gender': enums.Gender.MALE,
                    'level': enums.Level.BEGINNER,
                    'minAge': 1775811865,
                    'maxAge': 893145566,
                    'tournamentId': 995405759,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Category record.

        Parameters
        ----------
        where
            Category filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The deleted Category record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = Category.prisma().delete(
            where={
                'id': 2102736524,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Category record.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = Category.prisma().find_unique(
            where={
                'id': 271520213,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Category record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The found Category record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = Category.prisma().find_unique_or_raise(
            where={
                'id': 456633834,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Category records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N results
        where
            Category filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Category]
            The list of all Category records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Category records
        categorys = Category.prisma().find_many(take=10)

        # find the first 5 Category records ordered by the gender field
        categorys = Category.prisma().find_many(
            take=5,
            order={
                'gender': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Category record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the level field
        category = Category.prisma().find_first(
            skip=1,
            order={
                'level': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
        distinct: Optional[List[types.CategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Category record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Category model
        order
            Order the returned Category records by any field
        distinct
            Filter Category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Category
            The first Category record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Category record ordered by the minAge field
        category = Category.prisma().find_first_or_raise(
            skip=1,
            order={
                'minAge': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.CategoryUpdateInput,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Category record.

        Parameters
        ----------
        data
            Category record data specifying what to update
        where
            Category filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The updated Category record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        category = Category.prisma().update(
            where={
                'id': 2058258651,
            },
            data={
                # data to update the Category record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.CategoryWhereUniqueInput,
        data: types.CategoryUpsertInput,
        include: Optional[types.CategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Category filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Category model

        Returns
        -------
        prisma.models.Category
            The created or updated Category record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = Category.prisma().upsert(
            where={
                'id': 1583689592,
            },
            data={
                'create': {
                    'id': 1583689592,
                    'name': 'ecjjjfbae',
                    'gender': enums.Gender.MALE,
                    'level': enums.Level.BEGINNER,
                    'minAge': 1775811865,
                    'maxAge': 893145566,
                    'tournamentId': 995405759,
                },
                'update': {
                    'name': 'ecjjjfbae',
                    'gender': enums.Gender.MALE,
                    'level': enums.Level.BEGINNER,
                    'minAge': 1775811865,
                    'maxAge': 893145566,
                    'tournamentId': 995405759,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.CategoryUpdateManyMutationInput,
        where: types.CategoryWhereInput,
    ) -> int:
        """Update multiple Category records

        Parameters
        ----------
        data
            Category data to update the selected Category records to
        where
            Filter to select the Category records to update

        Returns
        -------
        int
            The total number of Category records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Category records
        total = Category.prisma().update_many(
            data={
                'maxAge': 878442065
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = Category.prisma().count(
            select={
                '_all': True,
                'tournamentId': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> types.CategoryCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
    ) -> Union[int, types.CategoryCountAggregateOutput]:
        """Count the number of Category records present in the database

        Parameters
        ----------
        select
            Select the Category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Category.prisma().count()

        # results: prisma.types.CategoryCountAggregateOutput
        results = Category.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CategoryCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CategoryWhereInput] = None
    ) -> int:
        """Delete multiple Category records.

        Parameters
        ----------
        where
            Optional Category filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Category records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Category records
        total = Category.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CategoryScalarFieldKeys'],
        *,
        where: Optional['types.CategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CategoryAvgAggregateInput'] = None,
        sum: Optional['types.CategorySumAggregateInput'] = None,
        min: Optional['types.CategoryMinAggregateInput'] = None,
        max: Optional['types.CategoryMaxAggregateInput'] = None,
        having: Optional['types.CategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CategoryGroupByOutput']:
        """Group Category records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Category fields to group records by
        where
            Category filter to select records
        take
            Limit the maximum number of Category records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CategoryGroupByOutput]
            A list of dictionaries representing the Category record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Category records by name values
        # and count how many records are in each group
        results = Category.prisma().group_by(
            ['name'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ParticipantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Participant]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Participant.prisma().query_raw(
            'SELECT * FROM Participant WHERE id = $1',
            1675280054,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Participant
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Participant.prisma().query_first(
            'SELECT * FROM Participant WHERE fullName = $1',
            'bgchfhgceh',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.ParticipantCreateInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> _PrismaModelT:
        """Create a new Participant record.

        Parameters
        ----------
        data
            Participant record data
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The created Participant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Participant record from just the required fields
        participant = Participant.prisma().create(
            data={
                # data to create a Participant record
                'fullName': 'cafeiaccbc',
                'birthDate': datetime.datetime.utcnow(),
                'gender': enums.Gender.MALE,
                'tournamentId': 60335757,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.ParticipantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Participant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Participant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Participant.prisma().create_many(
            data=[
                {
                    # data to create a Participant record
                    'fullName': 'gieegcbeg',
                    'birthDate': datetime.datetime.utcnow(),
                    'gender': enums.Gender.MALE,
                    'tournamentId': 1625503827,
                },
                {
                    # data to create a Participant record
                    'fullName': 'fcbichhci',
                    'birthDate': datetime.datetime.utcnow(),
                    'gender': enums.Gender.MALE,
                    'tournamentId': 1266032265,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Participant record.

        Parameters
        ----------
        where
            Participant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The deleted Participant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = Participant.prisma().delete(
            where={
                'id': 93253262,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Participant record.

        Parameters
        ----------
        where
            Participant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The found Participant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = Participant.prisma().find_unique(
            where={
                'id': 2053047983,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Participant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Participant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The found Participant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = Participant.prisma().find_unique_or_raise(
            where={
                'id': 685333180,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
        include: Optional[types.ParticipantInclude] = None,
        order: Optional[Union[types.ParticipantOrderByInput, List[types.ParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ParticipantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Participant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Participant records returned
        skip
            Ignore the first N results
        where
            Participant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Participant model
        order
            Order the returned Participant records by any field
        distinct
            Filter Participant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Participant]
            The list of all Participant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Participant records
        participants = Participant.prisma().find_many(take=10)

        # find the first 5 Participant records ordered by the birthDate field
        participants = Participant.prisma().find_many(
            take=5,
            order={
                'birthDate': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
        include: Optional[types.ParticipantInclude] = None,
        order: Optional[Union[types.ParticipantOrderByInput, List[types.ParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ParticipantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Participant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Participant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Participant model
        order
            Order the returned Participant records by any field
        distinct
            Filter Participant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Participant
            The first Participant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Participant record ordered by the gender field
        participant = Participant.prisma().find_first(
            skip=1,
            order={
                'gender': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
        include: Optional[types.ParticipantInclude] = None,
        order: Optional[Union[types.ParticipantOrderByInput, List[types.ParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.ParticipantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Participant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Participant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Participant model
        order
            Order the returned Participant records by any field
        distinct
            Filter Participant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Participant
            The first Participant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Participant record ordered by the email field
        participant = Participant.prisma().find_first_or_raise(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.ParticipantUpdateInput,
        where: types.ParticipantWhereUniqueInput,
        include: Optional[types.ParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Participant record.

        Parameters
        ----------
        data
            Participant record data specifying what to update
        where
            Participant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The updated Participant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        participant = Participant.prisma().update(
            where={
                'id': 127474245,
            },
            data={
                # data to update the Participant record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.ParticipantWhereUniqueInput,
        data: types.ParticipantUpsertInput,
        include: Optional[types.ParticipantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Participant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Participant model

        Returns
        -------
        prisma.models.Participant
            The created or updated Participant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        participant = Participant.prisma().upsert(
            where={
                'id': 948921754,
            },
            data={
                'create': {
                    'id': 948921754,
                    'fullName': 'fcbichhci',
                    'birthDate': datetime.datetime.utcnow(),
                    'gender': enums.Gender.MALE,
                    'tournamentId': 1266032265,
                },
                'update': {
                    'fullName': 'fcbichhci',
                    'birthDate': datetime.datetime.utcnow(),
                    'gender': enums.Gender.MALE,
                    'tournamentId': 1266032265,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.ParticipantUpdateManyMutationInput,
        where: types.ParticipantWhereInput,
    ) -> int:
        """Update multiple Participant records

        Parameters
        ----------
        data
            Participant data to update the selected Participant records to
        where
            Filter to select the Participant records to update

        Returns
        -------
        int
            The total number of Participant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Participant records
        total = Participant.prisma().update_many(
            data={
                'phone': 'bjgejjabff'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Participant records present in the database

        Parameters
        ----------
        select
            Select the Participant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Participant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Participant.prisma().count()

        # results: prisma.types.ParticipantCountAggregateOutput
        results = Participant.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.ParticipantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
    ) -> types.ParticipantCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.ParticipantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ParticipantWhereInput] = None,
        cursor: Optional[types.ParticipantWhereUniqueInput] = None,
    ) -> Union[int, types.ParticipantCountAggregateOutput]:
        """Count the number of Participant records present in the database

        Parameters
        ----------
        select
            Select the Participant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Participant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Participant.prisma().count()

        # results: prisma.types.ParticipantCountAggregateOutput
        results = Participant.prisma().count(
            select={
                '_all': True,
                'tournamentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ParticipantCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.ParticipantWhereInput] = None
    ) -> int:
        """Delete multiple Participant records.

        Parameters
        ----------
        where
            Optional Participant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Participant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Participant records
        total = Participant.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.ParticipantScalarFieldKeys'],
        *,
        where: Optional['types.ParticipantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ParticipantAvgAggregateInput'] = None,
        sum: Optional['types.ParticipantSumAggregateInput'] = None,
        min: Optional['types.ParticipantMinAggregateInput'] = None,
        max: Optional['types.ParticipantMaxAggregateInput'] = None,
        having: Optional['types.ParticipantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ParticipantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ParticipantScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ParticipantScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ParticipantGroupByOutput']:
        """Group Participant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Participant fields to group records by
        where
            Participant filter to select records
        take
            Limit the maximum number of Participant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ParticipantGroupByOutput]
            A list of dictionaries representing the Participant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Participant records by categoryId values
        # and count how many records are in each group
        results = Participant.prisma().group_by(
            ['categoryId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Team]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Team.prisma().query_raw(
            'SELECT * FROM Team WHERE id = $1',
            1228891816,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Team
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Team.prisma().query_first(
            'SELECT * FROM Team WHERE name = $1',
            'cffcachfd',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TeamCreateInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Create a new Team record.

        Parameters
        ----------
        data
            Team record data
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created Team record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Team record from just the required fields
        team = Team.prisma().create(
            data={
                # data to create a Team record
                'name': 'bccdfhdigc',
                'tournamentId': 541269159,
                'categoryId': 1064846676,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.TeamCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Team records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Team record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Team.prisma().create_many(
            data=[
                {
                    # data to create a Team record
                    'name': 'faidicegb',
                    'tournamentId': 1024265714,
                    'categoryId': 872078403,
                },
                {
                    # data to create a Team record
                    'name': 'biheheiajg',
                    'tournamentId': 916896761,
                    'categoryId': 769267518,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Team record.

        Parameters
        ----------
        where
            Team filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The deleted Team record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().delete(
            where={
                'id': 820312479,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Team record.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().find_unique(
            where={
                'id': 92728044,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Team record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Team filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The found Team record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().find_unique_or_raise(
            where={
                'id': 344858293,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Team records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N results
        where
            Team filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Team]
            The list of all Team records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Team records
        teams = Team.prisma().find_many(take=10)

        # find the first 5 Team records ordered by the tournamentId field
        teams = Team.prisma().find_many(
            take=5,
            order={
                'tournamentId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Team record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the categoryId field
        team = Team.prisma().find_first(
            skip=1,
            order={
                'categoryId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
        include: Optional[types.TeamInclude] = None,
        order: Optional[Union[types.TeamOrderByInput, List[types.TeamOrderByInput]]] = None,
        distinct: Optional[List[types.TeamScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Team record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Team filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Team model
        order
            Order the returned Team records by any field
        distinct
            Filter Team records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Team
            The first Team record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Team record ordered by the id field
        team = Team.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.TeamUpdateInput,
        where: types.TeamWhereUniqueInput,
        include: Optional[types.TeamInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Team record.

        Parameters
        ----------
        data
            Team record data specifying what to update
        where
            Team filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The updated Team record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        team = Team.prisma().update(
            where={
                'id': 1121741130,
            },
            data={
                # data to update the Team record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.TeamWhereUniqueInput,
        data: types.TeamUpsertInput,
        include: Optional[types.TeamInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Team filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Team model

        Returns
        -------
        prisma.models.Team
            The created or updated Team record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        team = Team.prisma().upsert(
            where={
                'id': 1495896251,
            },
            data={
                'create': {
                    'id': 1495896251,
                    'name': 'biheheiajg',
                    'tournamentId': 916896761,
                    'categoryId': 769267518,
                },
                'update': {
                    'name': 'biheheiajg',
                    'tournamentId': 916896761,
                    'categoryId': 769267518,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.TeamUpdateManyMutationInput,
        where: types.TeamWhereInput,
    ) -> int:
        """Update multiple Team records

        Parameters
        ----------
        data
            Team data to update the selected Team records to
        where
            Filter to select the Team records to update

        Returns
        -------
        int
            The total number of Team records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Team records
        total = Team.prisma().update_many(
            data={
                'name': 'caifcbgii'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = Team.prisma().count(
            select={
                '_all': True,
                'tournamentId': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TeamCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> types.TeamCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TeamCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamWhereInput] = None,
        cursor: Optional[types.TeamWhereUniqueInput] = None,
    ) -> Union[int, types.TeamCountAggregateOutput]:
        """Count the number of Team records present in the database

        Parameters
        ----------
        select
            Select the Team fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Team filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Team.prisma().count()

        # results: prisma.types.TeamCountAggregateOutput
        results = Team.prisma().count(
            select={
                '_all': True,
                'categoryId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TeamWhereInput] = None
    ) -> int:
        """Delete multiple Team records.

        Parameters
        ----------
        where
            Optional Team filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Team records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Team records
        total = Team.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TeamScalarFieldKeys'],
        *,
        where: Optional['types.TeamWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamAvgAggregateInput'] = None,
        sum: Optional['types.TeamSumAggregateInput'] = None,
        min: Optional['types.TeamMinAggregateInput'] = None,
        max: Optional['types.TeamMaxAggregateInput'] = None,
        having: Optional['types.TeamScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TeamScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamGroupByOutput']:
        """Group Team records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Team fields to group records by
        where
            Team filter to select records
        take
            Limit the maximum number of Team records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamGroupByOutput]
            A list of dictionaries representing the Team record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Team records by id values
        # and count how many records are in each group
        results = Team.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TeamParticipantActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TeamParticipant]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = TeamParticipant.prisma().query_raw(
            'SELECT * FROM TeamParticipant WHERE id = $1',
            860811569,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TeamParticipant
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = TeamParticipant.prisma().query_first(
            'SELECT * FROM TeamParticipant WHERE teamId = $1',
            1660932118,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.TeamParticipantCreateInput,
        include: Optional[types.TeamParticipantInclude] = None
    ) -> _PrismaModelT:
        """Create a new TeamParticipant record.

        Parameters
        ----------
        data
            TeamParticipant record data
        include
            Specifies which relations should be loaded on the returned TeamParticipant model

        Returns
        -------
        prisma.models.TeamParticipant
            The created TeamParticipant record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TeamParticipant record from just the required fields
        teamparticipant = TeamParticipant.prisma().create(
            data={
                # data to create a TeamParticipant record
                'teamId': 525761943,
                'participantId': 736209796,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.TeamParticipantCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TeamParticipant records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TeamParticipant record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = TeamParticipant.prisma().create_many(
            data=[
                {
                    # data to create a TeamParticipant record
                    'teamId': 493907821,
                    'participantId': 639686562,
                },
                {
                    # data to create a TeamParticipant record
                    'teamId': 654007347,
                    'participantId': 1905261552,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.TeamParticipantWhereUniqueInput,
        include: Optional[types.TeamParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TeamParticipant record.

        Parameters
        ----------
        where
            TeamParticipant filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TeamParticipant model

        Returns
        -------
        prisma.models.TeamParticipant
            The deleted TeamParticipant record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamparticipant = TeamParticipant.prisma().delete(
            where={
                'id': 78746985,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.TeamParticipantWhereUniqueInput,
        include: Optional[types.TeamParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TeamParticipant record.

        Parameters
        ----------
        where
            TeamParticipant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamParticipant model

        Returns
        -------
        prisma.models.TeamParticipant
            The found TeamParticipant record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamparticipant = TeamParticipant.prisma().find_unique(
            where={
                'id': 1398328302,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.TeamParticipantWhereUniqueInput,
        include: Optional[types.TeamParticipantInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TeamParticipant record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TeamParticipant filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TeamParticipant model

        Returns
        -------
        prisma.models.TeamParticipant
            The found TeamParticipant record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamparticipant = TeamParticipant.prisma().find_unique_or_raise(
            where={
                'id': 856000655,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamParticipantWhereInput] = None,
        cursor: Optional[types.TeamParticipantWhereUniqueInput] = None,
        include: Optional[types.TeamParticipantInclude] = None,
        order: Optional[Union[types.TeamParticipantOrderByInput, List[types.TeamParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.TeamParticipantScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TeamParticipant records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TeamParticipant records returned
        skip
            Ignore the first N results
        where
            TeamParticipant filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamParticipant model
        order
            Order the returned TeamParticipant records by any field
        distinct
            Filter TeamParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TeamParticipant]
            The list of all TeamParticipant records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TeamParticipant records
        teamparticipants = TeamParticipant.prisma().find_many(take=10)

        # find the first 5 TeamParticipant records ordered by the participantId field
        teamparticipants = TeamParticipant.prisma().find_many(
            take=5,
            order={
                'participantId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamParticipantWhereInput] = None,
        cursor: Optional[types.TeamParticipantWhereUniqueInput] = None,
        include: Optional[types.TeamParticipantInclude] = None,
        order: Optional[Union[types.TeamParticipantOrderByInput, List[types.TeamParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.TeamParticipantScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TeamParticipant record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamParticipant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamParticipant model
        order
            Order the returned TeamParticipant records by any field
        distinct
            Filter TeamParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamParticipant
            The first TeamParticipant record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamParticipant record ordered by the id field
        teamparticipant = TeamParticipant.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TeamParticipantWhereInput] = None,
        cursor: Optional[types.TeamParticipantWhereUniqueInput] = None,
        include: Optional[types.TeamParticipantInclude] = None,
        order: Optional[Union[types.TeamParticipantOrderByInput, List[types.TeamParticipantOrderByInput]]] = None,
        distinct: Optional[List[types.TeamParticipantScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TeamParticipant record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TeamParticipant filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TeamParticipant model
        order
            Order the returned TeamParticipant records by any field
        distinct
            Filter TeamParticipant records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TeamParticipant
            The first TeamParticipant record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TeamParticipant record ordered by the teamId field
        teamparticipant = TeamParticipant.prisma().find_first_or_raise(
            skip=1,
            order={
                'teamId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.TeamParticipantUpdateInput,
        where: types.TeamParticipantWhereUniqueInput,
        include: Optional[types.TeamParticipantInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TeamParticipant record.

        Parameters
        ----------
        data
            TeamParticipant record data specifying what to update
        where
            TeamParticipant filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TeamParticipant model

        Returns
        -------
        prisma.models.TeamParticipant
            The updated TeamParticipant record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        teamparticipant = TeamParticipant.prisma().update(
            where={
                'id': 1452336924,
            },
            data={
                # data to update the TeamParticipant record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.TeamParticipantWhereUniqueInput,
        data: types.TeamParticipantUpsertInput,
        include: Optional[types.TeamParticipantInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TeamParticipant filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TeamParticipant model

        Returns
        -------
        prisma.models.TeamParticipant
            The created or updated TeamParticipant record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        teamparticipant = TeamParticipant.prisma().upsert(
            where={
                'id': 1573199653,
            },
            data={
                'create': {
                    'id': 1573199653,
                    'teamId': 654007347,
                    'participantId': 1905261552,
                },
                'update': {
                    'teamId': 654007347,
                    'participantId': 1905261552,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.TeamParticipantUpdateManyMutationInput,
        where: types.TeamParticipantWhereInput,
    ) -> int:
        """Update multiple TeamParticipant records

        Parameters
        ----------
        data
            TeamParticipant data to update the selected TeamParticipant records to
        where
            Filter to select the TeamParticipant records to update

        Returns
        -------
        int
            The total number of TeamParticipant records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TeamParticipant records
        total = TeamParticipant.prisma().update_many(
            data={
                'participantId': 2013903098
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamParticipantWhereInput] = None,
        cursor: Optional[types.TeamParticipantWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TeamParticipant records present in the database

        Parameters
        ----------
        select
            Select the TeamParticipant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamParticipant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = TeamParticipant.prisma().count()

        # results: prisma.types.TeamParticipantCountAggregateOutput
        results = TeamParticipant.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.TeamParticipantCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamParticipantWhereInput] = None,
        cursor: Optional[types.TeamParticipantWhereUniqueInput] = None,
    ) -> types.TeamParticipantCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.TeamParticipantCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TeamParticipantWhereInput] = None,
        cursor: Optional[types.TeamParticipantWhereUniqueInput] = None,
    ) -> Union[int, types.TeamParticipantCountAggregateOutput]:
        """Count the number of TeamParticipant records present in the database

        Parameters
        ----------
        select
            Select the TeamParticipant fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TeamParticipant filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TeamParticipantCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = TeamParticipant.prisma().count()

        # results: prisma.types.TeamParticipantCountAggregateOutput
        results = TeamParticipant.prisma().count(
            select={
                '_all': True,
                'teamId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TeamParticipantCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.TeamParticipantWhereInput] = None
    ) -> int:
        """Delete multiple TeamParticipant records.

        Parameters
        ----------
        where
            Optional TeamParticipant filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TeamParticipant records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TeamParticipant records
        total = TeamParticipant.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.TeamParticipantScalarFieldKeys'],
        *,
        where: Optional['types.TeamParticipantWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TeamParticipantAvgAggregateInput'] = None,
        sum: Optional['types.TeamParticipantSumAggregateInput'] = None,
        min: Optional['types.TeamParticipantMinAggregateInput'] = None,
        max: Optional['types.TeamParticipantMaxAggregateInput'] = None,
        having: Optional['types.TeamParticipantScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TeamParticipantCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TeamParticipantScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TeamParticipantScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TeamParticipantGroupByOutput']:
        """Group TeamParticipant records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TeamParticipant fields to group records by
        where
            TeamParticipant filter to select records
        take
            Limit the maximum number of TeamParticipant records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TeamParticipantGroupByOutput]
            A list of dictionaries representing the TeamParticipant record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TeamParticipant records by participantId values
        # and count how many records are in each group
        results = TeamParticipant.prisma().group_by(
            ['participantId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CourtActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Court]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Court.prisma().query_raw(
            'SELECT * FROM Court WHERE id = $1',
            500965035,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Court
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Court.prisma().query_first(
            'SELECT * FROM Court WHERE name = $1',
            'biaagcedjc',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.CourtCreateInput,
        include: Optional[types.CourtInclude] = None
    ) -> _PrismaModelT:
        """Create a new Court record.

        Parameters
        ----------
        data
            Court record data
        include
            Specifies which relations should be loaded on the returned Court model

        Returns
        -------
        prisma.models.Court
            The created Court record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Court record from just the required fields
        court = Court.prisma().create(
            data={
                # data to create a Court record
                'name': 'cahhaghecf',
                'tournamentId': 1672112838,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.CourtCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Court records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Court record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Court.prisma().create_many(
            data=[
                {
                    # data to create a Court record
                    'name': 'jcgghhgdj',
                    'tournamentId': 1447624116,
                },
                {
                    # data to create a Court record
                    'name': 'bhdiaidiaf',
                    'tournamentId': 340946258,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.CourtWhereUniqueInput,
        include: Optional[types.CourtInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Court record.

        Parameters
        ----------
        where
            Court filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Court model

        Returns
        -------
        prisma.models.Court
            The deleted Court record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        court = Court.prisma().delete(
            where={
                'id': 601077795,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.CourtWhereUniqueInput,
        include: Optional[types.CourtInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Court record.

        Parameters
        ----------
        where
            Court filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Court model

        Returns
        -------
        prisma.models.Court
            The found Court record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        court = Court.prisma().find_unique(
            where={
                'id': 290603296,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.CourtWhereUniqueInput,
        include: Optional[types.CourtInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Court record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Court filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Court model

        Returns
        -------
        prisma.models.Court
            The found Court record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        court = Court.prisma().find_unique_or_raise(
            where={
                'id': 1855826649,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CourtWhereInput] = None,
        cursor: Optional[types.CourtWhereUniqueInput] = None,
        include: Optional[types.CourtInclude] = None,
        order: Optional[Union[types.CourtOrderByInput, List[types.CourtOrderByInput]]] = None,
        distinct: Optional[List[types.CourtScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Court records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Court records returned
        skip
            Ignore the first N results
        where
            Court filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Court model
        order
            Order the returned Court records by any field
        distinct
            Filter Court records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Court]
            The list of all Court records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Court records
        courts = Court.prisma().find_many(take=10)

        # find the first 5 Court records ordered by the locationNote field
        courts = Court.prisma().find_many(
            take=5,
            order={
                'locationNote': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CourtWhereInput] = None,
        cursor: Optional[types.CourtWhereUniqueInput] = None,
        include: Optional[types.CourtInclude] = None,
        order: Optional[Union[types.CourtOrderByInput, List[types.CourtOrderByInput]]] = None,
        distinct: Optional[List[types.CourtScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Court record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Court filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Court model
        order
            Order the returned Court records by any field
        distinct
            Filter Court records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Court
            The first Court record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Court record ordered by the tournamentId field
        court = Court.prisma().find_first(
            skip=1,
            order={
                'tournamentId': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CourtWhereInput] = None,
        cursor: Optional[types.CourtWhereUniqueInput] = None,
        include: Optional[types.CourtInclude] = None,
        order: Optional[Union[types.CourtOrderByInput, List[types.CourtOrderByInput]]] = None,
        distinct: Optional[List[types.CourtScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Court record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Court filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Court model
        order
            Order the returned Court records by any field
        distinct
            Filter Court records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Court
            The first Court record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Court record ordered by the id field
        court = Court.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.CourtUpdateInput,
        where: types.CourtWhereUniqueInput,
        include: Optional[types.CourtInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Court record.

        Parameters
        ----------
        data
            Court record data specifying what to update
        where
            Court filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Court model

        Returns
        -------
        prisma.models.Court
            The updated Court record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        court = Court.prisma().update(
            where={
                'id': 1611009182,
            },
            data={
                # data to update the Court record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.CourtWhereUniqueInput,
        data: types.CourtUpsertInput,
        include: Optional[types.CourtInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Court filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Court model

        Returns
        -------
        prisma.models.Court
            The created or updated Court record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        court = Court.prisma().upsert(
            where={
                'id': 446673791,
            },
            data={
                'create': {
                    'id': 446673791,
                    'name': 'bhdiaidiaf',
                    'tournamentId': 340946258,
                },
                'update': {
                    'name': 'bhdiaidiaf',
                    'tournamentId': 340946258,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.CourtUpdateManyMutationInput,
        where: types.CourtWhereInput,
    ) -> int:
        """Update multiple Court records

        Parameters
        ----------
        data
            Court data to update the selected Court records to
        where
            Filter to select the Court records to update

        Returns
        -------
        int
            The total number of Court records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Court records
        total = Court.prisma().update_many(
            data={
                'name': 'daafgidjg'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CourtWhereInput] = None,
        cursor: Optional[types.CourtWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Court records present in the database

        Parameters
        ----------
        select
            Select the Court fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Court filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CourtCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Court.prisma().count()

        # results: prisma.types.CourtCountAggregateOutput
        results = Court.prisma().count(
            select={
                '_all': True,
                'locationNote': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.CourtCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CourtWhereInput] = None,
        cursor: Optional[types.CourtWhereUniqueInput] = None,
    ) -> types.CourtCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.CourtCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CourtWhereInput] = None,
        cursor: Optional[types.CourtWhereUniqueInput] = None,
    ) -> Union[int, types.CourtCountAggregateOutput]:
        """Count the number of Court records present in the database

        Parameters
        ----------
        select
            Select the Court fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Court filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CourtCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Court.prisma().count()

        # results: prisma.types.CourtCountAggregateOutput
        results = Court.prisma().count(
            select={
                '_all': True,
                'tournamentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CourtCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.CourtWhereInput] = None
    ) -> int:
        """Delete multiple Court records.

        Parameters
        ----------
        where
            Optional Court filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Court records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Court records
        total = Court.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.CourtScalarFieldKeys'],
        *,
        where: Optional['types.CourtWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CourtAvgAggregateInput'] = None,
        sum: Optional['types.CourtSumAggregateInput'] = None,
        min: Optional['types.CourtMinAggregateInput'] = None,
        max: Optional['types.CourtMaxAggregateInput'] = None,
        having: Optional['types.CourtScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CourtCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CourtScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CourtScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CourtGroupByOutput']:
        """Group Court records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Court fields to group records by
        where
            Court filter to select records
        take
            Limit the maximum number of Court records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CourtGroupByOutput]
            A list of dictionaries representing the Court record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Court records by id values
        # and count how many records are in each group
        results = Court.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MatchActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Match]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = Match.prisma().query_raw(
            'SELECT * FROM Match WHERE id = $1',
            632626069,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Match
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = Match.prisma().query_first(
            'SELECT * FROM Match WHERE round = $1',
            1724011690,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.MatchCreateInput,
        include: Optional[types.MatchInclude] = None
    ) -> _PrismaModelT:
        """Create a new Match record.

        Parameters
        ----------
        data
            Match record data
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The created Match record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Match record from just the required fields
        match = Match.prisma().create(
            data={
                # data to create a Match record
                'round': 470157467,
                'tournamentId': 1209209912,
                'categoryId': 1536744465,
                'homeTeamId': 424218998,
                'awayTeamId': 2125632375,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.MatchCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Match records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Match record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = Match.prisma().create_many(
            data=[
                {
                    # data to create a Match record
                    'round': 536951780,
                    'tournamentId': 924723277,
                    'categoryId': 1621937922,
                    'homeTeamId': 1848832019,
                    'awayTeamId': 1921528400,
                },
                {
                    # data to create a Match record
                    'round': 2100427849,
                    'tournamentId': 849140046,
                    'categoryId': 928152175,
                    'homeTeamId': 273032060,
                    'awayTeamId': 982848517,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Match record.

        Parameters
        ----------
        where
            Match filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The deleted Match record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = Match.prisma().delete(
            where={
                'id': 510737498,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Match record.

        Parameters
        ----------
        where
            Match filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The found Match record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = Match.prisma().find_unique(
            where={
                'id': 2117488267,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Match record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Match filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The found Match record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = Match.prisma().find_unique_or_raise(
            where={
                'id': 1401944936,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Match records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Match records returned
        skip
            Ignore the first N results
        where
            Match filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Match]
            The list of all Match records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Match records
        matchs = Match.prisma().find_many(take=10)

        # find the first 5 Match records ordered by the groupCode field
        matchs = Match.prisma().find_many(
            take=5,
            order={
                'groupCode': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Match record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Match filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Match
            The first Match record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Match record ordered by the scheduledAt field
        match = Match.prisma().find_first(
            skip=1,
            order={
                'scheduledAt': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
        include: Optional[types.MatchInclude] = None,
        order: Optional[Union[types.MatchOrderByInput, List[types.MatchOrderByInput]]] = None,
        distinct: Optional[List[types.MatchScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Match record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Match filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Match model
        order
            Order the returned Match records by any field
        distinct
            Filter Match records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Match
            The first Match record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Match record ordered by the startedAt field
        match = Match.prisma().find_first_or_raise(
            skip=1,
            order={
                'startedAt': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.MatchUpdateInput,
        where: types.MatchWhereUniqueInput,
        include: Optional[types.MatchInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Match record.

        Parameters
        ----------
        data
            Match record data specifying what to update
        where
            Match filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The updated Match record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        match = Match.prisma().update(
            where={
                'id': 1297607553,
            },
            data={
                # data to update the Match record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.MatchWhereUniqueInput,
        data: types.MatchUpsertInput,
        include: Optional[types.MatchInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Match filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Match model

        Returns
        -------
        prisma.models.Match
            The created or updated Match record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        match = Match.prisma().upsert(
            where={
                'id': 519488550,
            },
            data={
                'create': {
                    'id': 519488550,
                    'round': 2100427849,
                    'tournamentId': 849140046,
                    'categoryId': 928152175,
                    'homeTeamId': 273032060,
                    'awayTeamId': 982848517,
                },
                'update': {
                    'round': 2100427849,
                    'tournamentId': 849140046,
                    'categoryId': 928152175,
                    'homeTeamId': 273032060,
                    'awayTeamId': 982848517,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.MatchUpdateManyMutationInput,
        where: types.MatchWhereInput,
    ) -> int:
        """Update multiple Match records

        Parameters
        ----------
        data
            Match data to update the selected Match records to
        where
            Filter to select the Match records to update

        Returns
        -------
        int
            The total number of Match records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Match records
        total = Match.prisma().update_many(
            data={
                'finishedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Match records present in the database

        Parameters
        ----------
        select
            Select the Match fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Match filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Match.prisma().count()

        # results: prisma.types.MatchCountAggregateOutput
        results = Match.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.MatchCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> types.MatchCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.MatchCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MatchWhereInput] = None,
        cursor: Optional[types.MatchWhereUniqueInput] = None,
    ) -> Union[int, types.MatchCountAggregateOutput]:
        """Count the number of Match records present in the database

        Parameters
        ----------
        select
            Select the Match fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Match filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MatchCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = Match.prisma().count()

        # results: prisma.types.MatchCountAggregateOutput
        results = Match.prisma().count(
            select={
                '_all': True,
                'homeScore': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MatchCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.MatchWhereInput] = None
    ) -> int:
        """Delete multiple Match records.

        Parameters
        ----------
        where
            Optional Match filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Match records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Match records
        total = Match.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.MatchScalarFieldKeys'],
        *,
        where: Optional['types.MatchWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MatchAvgAggregateInput'] = None,
        sum: Optional['types.MatchSumAggregateInput'] = None,
        min: Optional['types.MatchMinAggregateInput'] = None,
        max: Optional['types.MatchMaxAggregateInput'] = None,
        having: Optional['types.MatchScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MatchCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MatchScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MatchScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MatchGroupByOutput']:
        """Group Match records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Match fields to group records by
        where
            Match filter to select records
        take
            Limit the maximum number of Match records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MatchGroupByOutput]
            A list of dictionaries representing the Match record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Match records by awayScore values
        # and count how many records are in each group
        results = Match.prisma().group_by(
            ['awayScore'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models