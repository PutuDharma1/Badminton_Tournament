# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _UserRoleListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.UserRole']]


class _UserRoleListFilterHasInput(TypedDict):
    has: 'enums.UserRole'


class _UserRoleListFilterHasEveryInput(TypedDict):
    has_every: List['enums.UserRole']


class _UserRoleListFilterHasSomeInput(TypedDict):
    has_some: List['enums.UserRole']


class _UserRoleListFilterIsEmptyInput(TypedDict):
    is_empty: bool


UserRoleListFilter = Union[
    _UserRoleListFilterHasInput,
    _UserRoleListFilterEqualsInput,
    _UserRoleListFilterHasSomeInput,
    _UserRoleListFilterIsEmptyInput,
    _UserRoleListFilterHasEveryInput,
]


class _UserRoleListUpdateSet(TypedDict):
    set: List['enums.UserRole']


class _UserRoleListUpdatePush(TypedDict):
    push: List['enums.UserRole']


UserRoleListUpdate = Union[
    List['enums.UserRole'],
    _UserRoleListUpdateSet,
    _UserRoleListUpdatePush,
]

class _GenderListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Gender']]


class _GenderListFilterHasInput(TypedDict):
    has: 'enums.Gender'


class _GenderListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Gender']


class _GenderListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Gender']


class _GenderListFilterIsEmptyInput(TypedDict):
    is_empty: bool


GenderListFilter = Union[
    _GenderListFilterHasInput,
    _GenderListFilterEqualsInput,
    _GenderListFilterHasSomeInput,
    _GenderListFilterIsEmptyInput,
    _GenderListFilterHasEveryInput,
]


class _GenderListUpdateSet(TypedDict):
    set: List['enums.Gender']


class _GenderListUpdatePush(TypedDict):
    push: List['enums.Gender']


GenderListUpdate = Union[
    List['enums.Gender'],
    _GenderListUpdateSet,
    _GenderListUpdatePush,
]

class _LevelListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.Level']]


class _LevelListFilterHasInput(TypedDict):
    has: 'enums.Level'


class _LevelListFilterHasEveryInput(TypedDict):
    has_every: List['enums.Level']


class _LevelListFilterHasSomeInput(TypedDict):
    has_some: List['enums.Level']


class _LevelListFilterIsEmptyInput(TypedDict):
    is_empty: bool


LevelListFilter = Union[
    _LevelListFilterHasInput,
    _LevelListFilterEqualsInput,
    _LevelListFilterHasSomeInput,
    _LevelListFilterIsEmptyInput,
    _LevelListFilterHasEveryInput,
]


class _LevelListUpdateSet(TypedDict):
    set: List['enums.Level']


class _LevelListUpdatePush(TypedDict):
    push: List['enums.Level']


LevelListUpdate = Union[
    List['enums.Level'],
    _LevelListUpdateSet,
    _LevelListUpdatePush,
]

class _MatchStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.MatchStatus']]


class _MatchStatusListFilterHasInput(TypedDict):
    has: 'enums.MatchStatus'


class _MatchStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.MatchStatus']


class _MatchStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.MatchStatus']


class _MatchStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


MatchStatusListFilter = Union[
    _MatchStatusListFilterHasInput,
    _MatchStatusListFilterEqualsInput,
    _MatchStatusListFilterHasSomeInput,
    _MatchStatusListFilterIsEmptyInput,
    _MatchStatusListFilterHasEveryInput,
]


class _MatchStatusListUpdateSet(TypedDict):
    set: List['enums.MatchStatus']


class _MatchStatusListUpdatePush(TypedDict):
    push: List['enums.MatchStatus']


MatchStatusListUpdate = Union[
    List['enums.MatchStatus'],
    _MatchStatusListUpdateSet,
    _MatchStatusListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    role: 'enums.UserRole'
    tournamentsCreated: 'TournamentCreateManyNestedWithoutRelationsInput'
    matchesRefereed: 'MatchCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    name: _str
    email: _str
    password: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    role: 'enums.UserRole'


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    name: _str
    email: _str
    password: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    email: _str
    password: _str
    role: 'enums.UserRole'
    tournamentsCreated: 'TournamentUpdateManyWithoutRelationsInput'
    matchesRefereed: 'MatchUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    email: _str
    password: _str
    role: 'enums.UserRole'


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_User_name_OrderByInput = TypedDict(
    '_User_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_password_OrderByInput = TypedDict(
    '_User_password_OrderByInput',
    {
        'password': 'SortOrder',
    },
    total=True
)

_User_role_OrderByInput = TypedDict(
    '_User_role_OrderByInput',
    {
        'role': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
    '_User_name_OrderByInput',
    '_User_email_OrderByInput',
    '_User_password_OrderByInput',
    '_User_role_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromUser']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromUser']


    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromUserRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromUserRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromUserRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromUserRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    createdBy: Union[bool, 'UserArgsFromUserRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromUserRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromUserRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive1']


class TournamentIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    createdBy: Union[bool, 'UserArgsFromUserRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromUserRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromUserRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive2']


class TournamentIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    createdBy: Union[bool, 'UserArgsFromUserRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromUserRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromUserRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive3']


class TournamentIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    createdBy: Union[bool, 'UserArgsFromUserRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromUserRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromUserRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive4']


class TournamentIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class TournamentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyTournamentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive1']


class CategoryIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive2']


class CategoryIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive3']


class CategoryIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromUserRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromUserRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive4']


class CategoryIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CategoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCategoryArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive1']
    category: Union[bool, 'CategoryArgsFromUserRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive1']


class ParticipantIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive2']
    category: Union[bool, 'CategoryArgsFromUserRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive2']


class ParticipantIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive3']
    category: Union[bool, 'CategoryArgsFromUserRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive3']


class ParticipantIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive4']
    category: Union[bool, 'CategoryArgsFromUserRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive4']


class ParticipantIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class ParticipantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyParticipantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive1']
    category: Union[bool, 'CategoryArgsFromUserRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromUserRecursive1']


class TeamIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive2']
    category: Union[bool, 'CategoryArgsFromUserRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromUserRecursive2']


class TeamIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive3']
    category: Union[bool, 'CategoryArgsFromUserRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromUserRecursive3']


class TeamIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive4']
    category: Union[bool, 'CategoryArgsFromUserRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromUserRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromUserRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromUserRecursive4']


class TeamIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class TeamArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyTeamArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    team: Union[bool, 'TeamArgsFromUserRecursive1']
    participant: Union[bool, 'ParticipantArgsFromUserRecursive1']


class TeamParticipantIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    team: Union[bool, 'TeamArgsFromUserRecursive2']
    participant: Union[bool, 'ParticipantArgsFromUserRecursive2']


class TeamParticipantIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    team: Union[bool, 'TeamArgsFromUserRecursive3']
    participant: Union[bool, 'ParticipantArgsFromUserRecursive3']


class TeamParticipantIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    team: Union[bool, 'TeamArgsFromUserRecursive4']
    participant: Union[bool, 'ParticipantArgsFromUserRecursive4']


class TeamParticipantIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class TeamParticipantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyTeamParticipantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive1']


class CourtIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive2']


class CourtIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive3']


class CourtIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromUserRecursive4']


class CourtIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CourtArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCourtArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive1']
    category: Union[bool, 'CategoryArgsFromUserRecursive1']
    court: Union[bool, 'CourtArgsFromUserRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromUserRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromUserRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromUserRecursive1']
    referee: Union[bool, 'UserArgsFromUserRecursive1']


class MatchIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive2']
    category: Union[bool, 'CategoryArgsFromUserRecursive2']
    court: Union[bool, 'CourtArgsFromUserRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromUserRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromUserRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromUserRecursive2']
    referee: Union[bool, 'UserArgsFromUserRecursive2']


class MatchIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive3']
    category: Union[bool, 'CategoryArgsFromUserRecursive3']
    court: Union[bool, 'CourtArgsFromUserRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromUserRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromUserRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromUserRecursive3']
    referee: Union[bool, 'UserArgsFromUserRecursive3']


class MatchIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    tournament: Union[bool, 'TournamentArgsFromUserRecursive4']
    category: Union[bool, 'CategoryArgsFromUserRecursive4']
    court: Union[bool, 'CourtArgsFromUserRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromUserRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromUserRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromUserRecursive4']
    referee: Union[bool, 'UserArgsFromUserRecursive4']


class MatchIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class MatchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyMatchArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: 'enums.UserRole'
    tournamentsCreated: 'TournamentListRelationFilter'
    matchesRefereed: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: 'enums.UserRole'
    tournamentsCreated: 'TournamentListRelationFilter'
    matchesRefereed: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: 'enums.UserRole'
    tournamentsCreated: 'TournamentListRelationFilter'
    matchesRefereed: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: 'enums.UserRole'
    tournamentsCreated: 'TournamentListRelationFilter'
    matchesRefereed: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    password: Union[_str, 'types.StringFilter']
    role: 'enums.UserRole'
    tournamentsCreated: 'TournamentListRelationFilter'
    matchesRefereed: 'MatchListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: 'enums.UserRole'

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: 'enums.UserRole'

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: 'enums.UserRole'

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: 'enums.UserRole'

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    password: Union[_str, 'types.StringWithAggregatesFilter']
    role: 'enums.UserRole'



class UserGroupByOutput(TypedDict, total=False):
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    email: _str
    password: _str
    role: 'enums.UserRole'
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""
    id: float


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""
    id: _int


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    email: _str
    password: _str
    role: 'enums.UserRole'


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    name: bool
    email: bool
    password: bool
    role: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    name: bool
    email: bool
    password: bool
    role: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""
    id: bool


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'name': bool,
        'email': bool,
        'password': bool,
        'role': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'name': int,
        'email': int,
        'password': int,
        'role': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'name',
    'email',
    'password',
    'role',
    'tournamentsCreated',
    'matchesRefereed',
]
UserScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'name',
    'email',
    'password',
    'role',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'tournamentsCreated',
        'matchesRefereed',
    ]

# Tournament types

class TournamentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Tournament create method"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    description: Optional[_str]
    createdById: Optional[_int]
    createdBy: 'UserCreateNestedWithoutRelationsInput'
    categories: 'CategoryCreateManyNestedWithoutRelationsInput'
    courts: 'CourtCreateManyNestedWithoutRelationsInput'
    participants: 'ParticipantCreateManyNestedWithoutRelationsInput'
    teams: 'TeamCreateManyNestedWithoutRelationsInput'
    matches: 'MatchCreateManyNestedWithoutRelationsInput'


class TournamentCreateInput(TournamentOptionalCreateInput):
    """Required arguments to the Tournament create method"""
    name: _str
    location: _str
    startDate: datetime.datetime
    endDate: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TournamentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Tournament create method, without relations"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    description: Optional[_str]
    createdById: Optional[_int]


class TournamentCreateWithoutRelationsInput(TournamentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Tournament create method, without relations"""
    name: _str
    location: _str
    startDate: datetime.datetime
    endDate: datetime.datetime

class TournamentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TournamentCreateWithoutRelationsInput'
    where: 'TournamentWhereUniqueInput'

class TournamentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TournamentCreateWithoutRelationsInput'
    connect: 'TournamentWhereUniqueInput'
    connect_or_create: 'TournamentConnectOrCreateWithoutRelationsInput'


class TournamentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TournamentCreateWithoutRelationsInput', List['TournamentCreateWithoutRelationsInput']]
    connect: Union['TournamentWhereUniqueInput', List['TournamentWhereUniqueInput']]
    connect_or_create: Union['TournamentConnectOrCreateWithoutRelationsInput', List['TournamentConnectOrCreateWithoutRelationsInput']]

_TournamentWhereUnique_id_Input = TypedDict(
    '_TournamentWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

TournamentWhereUniqueInput = _TournamentWhereUnique_id_Input


class TournamentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    location: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    description: Optional[_str]
    createdBy: 'UserUpdateOneWithoutRelationsInput'
    categories: 'CategoryUpdateManyWithoutRelationsInput'
    courts: 'CourtUpdateManyWithoutRelationsInput'
    participants: 'ParticipantUpdateManyWithoutRelationsInput'
    teams: 'TeamUpdateManyWithoutRelationsInput'
    matches: 'MatchUpdateManyWithoutRelationsInput'


class TournamentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    location: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    description: Optional[_str]


class TournamentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TournamentCreateWithoutRelationsInput']
    connect: List['TournamentWhereUniqueInput']
    connect_or_create: List['TournamentConnectOrCreateWithoutRelationsInput']
    set: List['TournamentWhereUniqueInput']
    disconnect: List['TournamentWhereUniqueInput']
    delete: List['TournamentWhereUniqueInput']

    # TODO
    # update: List['TournamentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TournamentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TournamentScalarWhereInput']
    # upsert: List['TournamentUpserteWithWhereUniqueWithoutRelationsInput']


class TournamentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TournamentCreateWithoutRelationsInput'
    connect: 'TournamentWhereUniqueInput'
    connect_or_create: 'TournamentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TournamentUpdateInput'
    # upsert: 'TournamentUpsertWithoutRelationsInput'


class TournamentUpsertInput(TypedDict):
    create: 'TournamentCreateInput'
    update: 'TournamentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Tournament_id_OrderByInput = TypedDict(
    '_Tournament_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Tournament_createdAt_OrderByInput = TypedDict(
    '_Tournament_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Tournament_updatedAt_OrderByInput = TypedDict(
    '_Tournament_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Tournament_name_OrderByInput = TypedDict(
    '_Tournament_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Tournament_location_OrderByInput = TypedDict(
    '_Tournament_location_OrderByInput',
    {
        'location': 'SortOrder',
    },
    total=True
)

_Tournament_startDate_OrderByInput = TypedDict(
    '_Tournament_startDate_OrderByInput',
    {
        'startDate': 'SortOrder',
    },
    total=True
)

_Tournament_endDate_OrderByInput = TypedDict(
    '_Tournament_endDate_OrderByInput',
    {
        'endDate': 'SortOrder',
    },
    total=True
)

_Tournament_description_OrderByInput = TypedDict(
    '_Tournament_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Tournament_createdById_OrderByInput = TypedDict(
    '_Tournament_createdById_OrderByInput',
    {
        'createdById': 'SortOrder',
    },
    total=True
)

_Tournament_RelevanceInner = TypedDict(
    '_Tournament_RelevanceInner',
    {
        'fields': 'List[TournamentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Tournament_RelevanceOrderByInput = TypedDict(
    '_Tournament_RelevanceOrderByInput',
    {
        '_relevance': '_Tournament_RelevanceInner',
    },
    total=True
)

TournamentOrderByInput = Union[
    '_Tournament_id_OrderByInput',
    '_Tournament_createdAt_OrderByInput',
    '_Tournament_updatedAt_OrderByInput',
    '_Tournament_name_OrderByInput',
    '_Tournament_location_OrderByInput',
    '_Tournament_startDate_OrderByInput',
    '_Tournament_endDate_OrderByInput',
    '_Tournament_description_OrderByInput',
    '_Tournament_createdById_OrderByInput',
    '_Tournament_RelevanceOrderByInput',
]



# recursive Tournament types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TournamentRelationFilter = TypedDict(
    'TournamentRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TournamentListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TournamentInclude(TypedDict, total=False):
    """Tournament relational arguments"""
    createdBy: Union[bool, 'UserArgsFromTournament']
    categories: Union[bool, 'FindManyCategoryArgsFromTournament']
    courts: Union[bool, 'FindManyCourtArgsFromTournament']
    participants: Union[bool, 'FindManyParticipantArgsFromTournament']
    teams: Union[bool, 'FindManyTeamArgsFromTournament']
    matches: Union[bool, 'FindManyMatchArgsFromTournament']


    

class UserIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTournamentRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTournamentRecursive1']


class UserIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTournamentRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTournamentRecursive2']


class UserIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTournamentRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTournamentRecursive3']


class UserIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTournamentRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTournamentRecursive4']


class UserIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class UserArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyUserArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    createdBy: Union[bool, 'UserArgsFromTournamentRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromTournamentRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromTournamentRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive1']


class TournamentIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    createdBy: Union[bool, 'UserArgsFromTournamentRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromTournamentRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromTournamentRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive2']


class TournamentIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    createdBy: Union[bool, 'UserArgsFromTournamentRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromTournamentRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromTournamentRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive3']


class TournamentIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    createdBy: Union[bool, 'UserArgsFromTournamentRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromTournamentRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromTournamentRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive4']


class TournamentIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class TournamentArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyTournamentArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive1']


class CategoryIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive2']


class CategoryIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive3']


class CategoryIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromTournamentRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTournamentRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive4']


class CategoryIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class CategoryArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyCategoryArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive1']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive1']


class ParticipantIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive2']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive2']


class ParticipantIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive3']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive3']


class ParticipantIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive4']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive4']


class ParticipantIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class ParticipantArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyParticipantArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive1']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTournamentRecursive1']


class TeamIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive2']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTournamentRecursive2']


class TeamIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive3']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTournamentRecursive3']


class TeamIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive4']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTournamentRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTournamentRecursive4']


class TeamIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class TeamArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyTeamArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    team: Union[bool, 'TeamArgsFromTournamentRecursive1']
    participant: Union[bool, 'ParticipantArgsFromTournamentRecursive1']


class TeamParticipantIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    team: Union[bool, 'TeamArgsFromTournamentRecursive2']
    participant: Union[bool, 'ParticipantArgsFromTournamentRecursive2']


class TeamParticipantIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    team: Union[bool, 'TeamArgsFromTournamentRecursive3']
    participant: Union[bool, 'ParticipantArgsFromTournamentRecursive3']


class TeamParticipantIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    team: Union[bool, 'TeamArgsFromTournamentRecursive4']
    participant: Union[bool, 'ParticipantArgsFromTournamentRecursive4']


class TeamParticipantIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class TeamParticipantArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyTeamParticipantArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive1']


class CourtIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive2']


class CourtIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive3']


class CourtIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTournamentRecursive4']


class CourtIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class CourtArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyCourtArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromTournament(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive1']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive1']
    court: Union[bool, 'CourtArgsFromTournamentRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromTournamentRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromTournamentRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromTournamentRecursive1']
    referee: Union[bool, 'UserArgsFromTournamentRecursive1']


class MatchIncludeFromTournamentRecursive1(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive2']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive2']
    court: Union[bool, 'CourtArgsFromTournamentRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromTournamentRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromTournamentRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromTournamentRecursive2']
    referee: Union[bool, 'UserArgsFromTournamentRecursive2']


class MatchIncludeFromTournamentRecursive2(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive3']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive3']
    court: Union[bool, 'CourtArgsFromTournamentRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromTournamentRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromTournamentRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromTournamentRecursive3']
    referee: Union[bool, 'UserArgsFromTournamentRecursive3']


class MatchIncludeFromTournamentRecursive3(TypedDict, total=False):
    """Relational arguments for Tournament"""
    tournament: Union[bool, 'TournamentArgsFromTournamentRecursive4']
    category: Union[bool, 'CategoryArgsFromTournamentRecursive4']
    court: Union[bool, 'CourtArgsFromTournamentRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromTournamentRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromTournamentRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromTournamentRecursive4']
    referee: Union[bool, 'UserArgsFromTournamentRecursive4']


class MatchIncludeFromTournamentRecursive4(TypedDict, total=False):
    """Relational arguments for Tournament"""

    

class MatchArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    
    

class FindManyMatchArgsFromTournament(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromTournamentRecursive1(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromTournamentRecursive2(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromTournamentRecursive3(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromTournamentRecursive4(TypedDict, total=False):
    """Arguments for Tournament"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyTournamentArgs = FindManyTournamentArgsFromTournament
FindFirstTournamentArgs = FindManyTournamentArgsFromTournament


    

class TournamentWhereInput(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    location: Union[_str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdById: Union[None, _int, 'types.IntFilter']
    createdBy: 'UserRelationFilter'
    categories: 'CategoryListRelationFilter'
    courts: 'CourtListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TournamentWhereInputRecursive1', List['TournamentWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TournamentWhereInputRecursive1']
    OR: List['TournamentWhereInputRecursive1']
    NOT: List['TournamentWhereInputRecursive1']


class TournamentWhereInputRecursive1(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    location: Union[_str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdById: Union[None, _int, 'types.IntFilter']
    createdBy: 'UserRelationFilter'
    categories: 'CategoryListRelationFilter'
    courts: 'CourtListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TournamentWhereInputRecursive2', List['TournamentWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TournamentWhereInputRecursive2']
    OR: List['TournamentWhereInputRecursive2']
    NOT: List['TournamentWhereInputRecursive2']


class TournamentWhereInputRecursive2(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    location: Union[_str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdById: Union[None, _int, 'types.IntFilter']
    createdBy: 'UserRelationFilter'
    categories: 'CategoryListRelationFilter'
    courts: 'CourtListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TournamentWhereInputRecursive3', List['TournamentWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TournamentWhereInputRecursive3']
    OR: List['TournamentWhereInputRecursive3']
    NOT: List['TournamentWhereInputRecursive3']


class TournamentWhereInputRecursive3(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    location: Union[_str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdById: Union[None, _int, 'types.IntFilter']
    createdBy: 'UserRelationFilter'
    categories: 'CategoryListRelationFilter'
    courts: 'CourtListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TournamentWhereInputRecursive4', List['TournamentWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TournamentWhereInputRecursive4']
    OR: List['TournamentWhereInputRecursive4']
    NOT: List['TournamentWhereInputRecursive4']


class TournamentWhereInputRecursive4(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    name: Union[_str, 'types.StringFilter']
    location: Union[_str, 'types.StringFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeFilter']
    description: Union[None, _str, 'types.StringFilter']
    createdById: Union[None, _int, 'types.IntFilter']
    createdBy: 'UserRelationFilter'
    categories: 'CategoryListRelationFilter'
    courts: 'CourtListRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'



# aggregate Tournament types


    

class TournamentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TournamentScalarWhereWithAggregatesInputRecursive1']
    OR: List['TournamentScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TournamentScalarWhereWithAggregatesInputRecursive1']


class TournamentScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TournamentScalarWhereWithAggregatesInputRecursive2']
    OR: List['TournamentScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TournamentScalarWhereWithAggregatesInputRecursive2']


class TournamentScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TournamentScalarWhereWithAggregatesInputRecursive3']
    OR: List['TournamentScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TournamentScalarWhereWithAggregatesInputRecursive3']


class TournamentScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TournamentScalarWhereWithAggregatesInputRecursive4']
    OR: List['TournamentScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TournamentScalarWhereWithAggregatesInputRecursive4']


class TournamentScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Tournament arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    createdById: Union[_int, 'types.IntWithAggregatesFilter']



class TournamentGroupByOutput(TypedDict, total=False):
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    location: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    description: _str
    createdById: _int
    _sum: 'TournamentSumAggregateOutput'
    _avg: 'TournamentAvgAggregateOutput'
    _min: 'TournamentMinAggregateOutput'
    _max: 'TournamentMaxAggregateOutput'
    _count: 'TournamentCountAggregateOutput'


class TournamentAvgAggregateOutput(TypedDict, total=False):
    """Tournament output for aggregating averages"""
    id: float
    createdById: float


class TournamentSumAggregateOutput(TypedDict, total=False):
    """Tournament output for aggregating sums"""
    id: _int
    createdById: _int


class TournamentScalarAggregateOutput(TypedDict, total=False):
    """Tournament output including scalar fields"""
    id: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    name: _str
    location: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    description: _str
    createdById: _int


TournamentMinAggregateOutput = TournamentScalarAggregateOutput
TournamentMaxAggregateOutput = TournamentScalarAggregateOutput


class TournamentMaxAggregateInput(TypedDict, total=False):
    """Tournament input for aggregating by max"""
    id: bool
    createdAt: bool
    updatedAt: bool
    name: bool
    location: bool
    startDate: bool
    endDate: bool
    description: bool
    createdById: bool


class TournamentMinAggregateInput(TypedDict, total=False):
    """Tournament input for aggregating by min"""
    id: bool
    createdAt: bool
    updatedAt: bool
    name: bool
    location: bool
    startDate: bool
    endDate: bool
    description: bool
    createdById: bool


class TournamentNumberAggregateInput(TypedDict, total=False):
    """Tournament input for aggregating numbers"""
    id: bool
    createdById: bool


TournamentAvgAggregateInput = TournamentNumberAggregateInput
TournamentSumAggregateInput = TournamentNumberAggregateInput


TournamentCountAggregateInput = TypedDict(
    'TournamentCountAggregateInput',
    {
        'id': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'name': bool,
        'location': bool,
        'startDate': bool,
        'endDate': bool,
        'description': bool,
        'createdById': bool,
        '_all': bool,
    },
    total=False,
)

TournamentCountAggregateOutput = TypedDict(
    'TournamentCountAggregateOutput',
    {
        'id': int,
        'createdAt': int,
        'updatedAt': int,
        'name': int,
        'location': int,
        'startDate': int,
        'endDate': int,
        'description': int,
        'createdById': int,
        '_all': int,
    },
    total=False,
)


TournamentKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'name',
    'location',
    'startDate',
    'endDate',
    'description',
    'createdById',
    'createdBy',
    'categories',
    'courts',
    'participants',
    'teams',
    'matches',
]
TournamentScalarFieldKeys = Literal[
    'id',
    'createdAt',
    'updatedAt',
    'name',
    'location',
    'startDate',
    'endDate',
    'description',
    'createdById',
]
TournamentScalarFieldKeysT = TypeVar('TournamentScalarFieldKeysT', bound=TournamentScalarFieldKeys)

TournamentRelationalFieldKeys = Literal[
        'createdBy',
        'categories',
        'courts',
        'participants',
        'teams',
        'matches',
    ]

# Category types

class CategoryOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Category create method"""
    id: _int
    tournamentId: _int
    tournament: 'TournamentCreateNestedWithoutRelationsInput'
    participants: 'ParticipantCreateManyNestedWithoutRelationsInput'
    teams: 'TeamCreateManyNestedWithoutRelationsInput'
    matches: 'MatchCreateManyNestedWithoutRelationsInput'


class CategoryCreateInput(CategoryOptionalCreateInput):
    """Required arguments to the Category create method"""
    name: _str
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: _int
    maxAge: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CategoryOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Category create method, without relations"""
    id: _int
    tournamentId: _int


class CategoryCreateWithoutRelationsInput(CategoryOptionalCreateWithoutRelationsInput):
    """Required arguments to the Category create method, without relations"""
    name: _str
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: _int
    maxAge: _int

class CategoryConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CategoryCreateWithoutRelationsInput'
    where: 'CategoryWhereUniqueInput'

class CategoryCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CategoryCreateWithoutRelationsInput'
    connect: 'CategoryWhereUniqueInput'
    connect_or_create: 'CategoryConnectOrCreateWithoutRelationsInput'


class CategoryCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CategoryCreateWithoutRelationsInput', List['CategoryCreateWithoutRelationsInput']]
    connect: Union['CategoryWhereUniqueInput', List['CategoryWhereUniqueInput']]
    connect_or_create: Union['CategoryConnectOrCreateWithoutRelationsInput', List['CategoryConnectOrCreateWithoutRelationsInput']]

_CategoryWhereUnique_id_Input = TypedDict(
    '_CategoryWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

CategoryWhereUniqueInput = _CategoryWhereUnique_id_Input


class CategoryUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[AtomicIntInput, _int]
    maxAge: Union[AtomicIntInput, _int]
    tournament: 'TournamentUpdateOneWithoutRelationsInput'
    participants: 'ParticipantUpdateManyWithoutRelationsInput'
    teams: 'TeamUpdateManyWithoutRelationsInput'
    matches: 'MatchUpdateManyWithoutRelationsInput'


class CategoryUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[AtomicIntInput, _int]
    maxAge: Union[AtomicIntInput, _int]


class CategoryUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CategoryCreateWithoutRelationsInput']
    connect: List['CategoryWhereUniqueInput']
    connect_or_create: List['CategoryConnectOrCreateWithoutRelationsInput']
    set: List['CategoryWhereUniqueInput']
    disconnect: List['CategoryWhereUniqueInput']
    delete: List['CategoryWhereUniqueInput']

    # TODO
    # update: List['CategoryUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CategoryUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CategoryScalarWhereInput']
    # upsert: List['CategoryUpserteWithWhereUniqueWithoutRelationsInput']


class CategoryUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CategoryCreateWithoutRelationsInput'
    connect: 'CategoryWhereUniqueInput'
    connect_or_create: 'CategoryConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CategoryUpdateInput'
    # upsert: 'CategoryUpsertWithoutRelationsInput'


class CategoryUpsertInput(TypedDict):
    create: 'CategoryCreateInput'
    update: 'CategoryUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Category_id_OrderByInput = TypedDict(
    '_Category_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Category_name_OrderByInput = TypedDict(
    '_Category_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Category_gender_OrderByInput = TypedDict(
    '_Category_gender_OrderByInput',
    {
        'gender': 'SortOrder',
    },
    total=True
)

_Category_level_OrderByInput = TypedDict(
    '_Category_level_OrderByInput',
    {
        'level': 'SortOrder',
    },
    total=True
)

_Category_minAge_OrderByInput = TypedDict(
    '_Category_minAge_OrderByInput',
    {
        'minAge': 'SortOrder',
    },
    total=True
)

_Category_maxAge_OrderByInput = TypedDict(
    '_Category_maxAge_OrderByInput',
    {
        'maxAge': 'SortOrder',
    },
    total=True
)

_Category_tournamentId_OrderByInput = TypedDict(
    '_Category_tournamentId_OrderByInput',
    {
        'tournamentId': 'SortOrder',
    },
    total=True
)

_Category_RelevanceInner = TypedDict(
    '_Category_RelevanceInner',
    {
        'fields': 'List[CategoryScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Category_RelevanceOrderByInput = TypedDict(
    '_Category_RelevanceOrderByInput',
    {
        '_relevance': '_Category_RelevanceInner',
    },
    total=True
)

CategoryOrderByInput = Union[
    '_Category_id_OrderByInput',
    '_Category_name_OrderByInput',
    '_Category_gender_OrderByInput',
    '_Category_level_OrderByInput',
    '_Category_minAge_OrderByInput',
    '_Category_maxAge_OrderByInput',
    '_Category_tournamentId_OrderByInput',
    '_Category_RelevanceOrderByInput',
]



# recursive Category types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CategoryRelationFilter = TypedDict(
    'CategoryRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CategoryListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CategoryInclude(TypedDict, total=False):
    """Category relational arguments"""
    tournament: Union[bool, 'TournamentArgsFromCategory']
    participants: Union[bool, 'FindManyParticipantArgsFromCategory']
    teams: Union[bool, 'FindManyTeamArgsFromCategory']
    matches: Union[bool, 'FindManyMatchArgsFromCategory']


    

class UserIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCategoryRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCategoryRecursive1']


class UserIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCategoryRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCategoryRecursive2']


class UserIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCategoryRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCategoryRecursive3']


class UserIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCategoryRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCategoryRecursive4']


class UserIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class UserArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyUserArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    createdBy: Union[bool, 'UserArgsFromCategoryRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromCategoryRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromCategoryRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive1']


class TournamentIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    createdBy: Union[bool, 'UserArgsFromCategoryRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromCategoryRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromCategoryRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive2']


class TournamentIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    createdBy: Union[bool, 'UserArgsFromCategoryRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromCategoryRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromCategoryRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive3']


class TournamentIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    createdBy: Union[bool, 'UserArgsFromCategoryRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromCategoryRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromCategoryRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive4']


class TournamentIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class TournamentArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyTournamentArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive1']


class CategoryIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive2']


class CategoryIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive3']


class CategoryIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromCategoryRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromCategoryRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive4']


class CategoryIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class CategoryArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyCategoryArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive1']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive1']


class ParticipantIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive2']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive2']


class ParticipantIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive3']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive3']


class ParticipantIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive4']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive4']


class ParticipantIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class ParticipantArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyParticipantArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive1']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCategoryRecursive1']


class TeamIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive2']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCategoryRecursive2']


class TeamIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive3']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCategoryRecursive3']


class TeamIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive4']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCategoryRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCategoryRecursive4']


class TeamIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class TeamArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyTeamArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    team: Union[bool, 'TeamArgsFromCategoryRecursive1']
    participant: Union[bool, 'ParticipantArgsFromCategoryRecursive1']


class TeamParticipantIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    team: Union[bool, 'TeamArgsFromCategoryRecursive2']
    participant: Union[bool, 'ParticipantArgsFromCategoryRecursive2']


class TeamParticipantIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    team: Union[bool, 'TeamArgsFromCategoryRecursive3']
    participant: Union[bool, 'ParticipantArgsFromCategoryRecursive3']


class TeamParticipantIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    team: Union[bool, 'TeamArgsFromCategoryRecursive4']
    participant: Union[bool, 'ParticipantArgsFromCategoryRecursive4']


class TeamParticipantIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class TeamParticipantArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyTeamParticipantArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive1']


class CourtIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive2']


class CourtIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive3']


class CourtIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromCategoryRecursive4']


class CourtIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class CourtArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyCourtArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromCategory(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive1']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive1']
    court: Union[bool, 'CourtArgsFromCategoryRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromCategoryRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromCategoryRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromCategoryRecursive1']
    referee: Union[bool, 'UserArgsFromCategoryRecursive1']


class MatchIncludeFromCategoryRecursive1(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive2']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive2']
    court: Union[bool, 'CourtArgsFromCategoryRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromCategoryRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromCategoryRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromCategoryRecursive2']
    referee: Union[bool, 'UserArgsFromCategoryRecursive2']


class MatchIncludeFromCategoryRecursive2(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive3']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive3']
    court: Union[bool, 'CourtArgsFromCategoryRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromCategoryRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromCategoryRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromCategoryRecursive3']
    referee: Union[bool, 'UserArgsFromCategoryRecursive3']


class MatchIncludeFromCategoryRecursive3(TypedDict, total=False):
    """Relational arguments for Category"""
    tournament: Union[bool, 'TournamentArgsFromCategoryRecursive4']
    category: Union[bool, 'CategoryArgsFromCategoryRecursive4']
    court: Union[bool, 'CourtArgsFromCategoryRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromCategoryRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromCategoryRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromCategoryRecursive4']
    referee: Union[bool, 'UserArgsFromCategoryRecursive4']


class MatchIncludeFromCategoryRecursive4(TypedDict, total=False):
    """Relational arguments for Category"""

    

class MatchArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    
    

class FindManyMatchArgsFromCategory(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromCategoryRecursive1(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromCategoryRecursive2(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromCategoryRecursive3(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromCategoryRecursive4(TypedDict, total=False):
    """Arguments for Category"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyCategoryArgs = FindManyCategoryArgsFromCategory
FindFirstCategoryArgs = FindManyCategoryArgsFromCategory


    

class CategoryWhereInput(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntFilter']
    maxAge: Union[_int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CategoryWhereInputRecursive1', List['CategoryWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CategoryWhereInputRecursive1']
    OR: List['CategoryWhereInputRecursive1']
    NOT: List['CategoryWhereInputRecursive1']


class CategoryWhereInputRecursive1(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntFilter']
    maxAge: Union[_int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CategoryWhereInputRecursive2', List['CategoryWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CategoryWhereInputRecursive2']
    OR: List['CategoryWhereInputRecursive2']
    NOT: List['CategoryWhereInputRecursive2']


class CategoryWhereInputRecursive2(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntFilter']
    maxAge: Union[_int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CategoryWhereInputRecursive3', List['CategoryWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CategoryWhereInputRecursive3']
    OR: List['CategoryWhereInputRecursive3']
    NOT: List['CategoryWhereInputRecursive3']


class CategoryWhereInputRecursive3(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntFilter']
    maxAge: Union[_int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CategoryWhereInputRecursive4', List['CategoryWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CategoryWhereInputRecursive4']
    OR: List['CategoryWhereInputRecursive4']
    NOT: List['CategoryWhereInputRecursive4']


class CategoryWhereInputRecursive4(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntFilter']
    maxAge: Union[_int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    participants: 'ParticipantListRelationFilter'
    teams: 'TeamListRelationFilter'
    matches: 'MatchListRelationFilter'



# aggregate Category types


    

class CategoryScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntWithAggregatesFilter']
    maxAge: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CategoryScalarWhereWithAggregatesInputRecursive1']
    OR: List['CategoryScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CategoryScalarWhereWithAggregatesInputRecursive1']


class CategoryScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntWithAggregatesFilter']
    maxAge: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CategoryScalarWhereWithAggregatesInputRecursive2']
    OR: List['CategoryScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CategoryScalarWhereWithAggregatesInputRecursive2']


class CategoryScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntWithAggregatesFilter']
    maxAge: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CategoryScalarWhereWithAggregatesInputRecursive3']
    OR: List['CategoryScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CategoryScalarWhereWithAggregatesInputRecursive3']


class CategoryScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntWithAggregatesFilter']
    maxAge: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CategoryScalarWhereWithAggregatesInputRecursive4']
    OR: List['CategoryScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CategoryScalarWhereWithAggregatesInputRecursive4']


class CategoryScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Category arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: Union[_int, 'types.IntWithAggregatesFilter']
    maxAge: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']



class CategoryGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: _int
    maxAge: _int
    tournamentId: _int
    _sum: 'CategorySumAggregateOutput'
    _avg: 'CategoryAvgAggregateOutput'
    _min: 'CategoryMinAggregateOutput'
    _max: 'CategoryMaxAggregateOutput'
    _count: 'CategoryCountAggregateOutput'


class CategoryAvgAggregateOutput(TypedDict, total=False):
    """Category output for aggregating averages"""
    id: float
    minAge: float
    maxAge: float
    tournamentId: float


class CategorySumAggregateOutput(TypedDict, total=False):
    """Category output for aggregating sums"""
    id: _int
    minAge: _int
    maxAge: _int
    tournamentId: _int


class CategoryScalarAggregateOutput(TypedDict, total=False):
    """Category output including scalar fields"""
    id: _int
    name: _str
    gender: 'enums.Gender'
    level: 'enums.Level'
    minAge: _int
    maxAge: _int
    tournamentId: _int


CategoryMinAggregateOutput = CategoryScalarAggregateOutput
CategoryMaxAggregateOutput = CategoryScalarAggregateOutput


class CategoryMaxAggregateInput(TypedDict, total=False):
    """Category input for aggregating by max"""
    id: bool
    name: bool
    gender: bool
    level: bool
    minAge: bool
    maxAge: bool
    tournamentId: bool


class CategoryMinAggregateInput(TypedDict, total=False):
    """Category input for aggregating by min"""
    id: bool
    name: bool
    gender: bool
    level: bool
    minAge: bool
    maxAge: bool
    tournamentId: bool


class CategoryNumberAggregateInput(TypedDict, total=False):
    """Category input for aggregating numbers"""
    id: bool
    minAge: bool
    maxAge: bool
    tournamentId: bool


CategoryAvgAggregateInput = CategoryNumberAggregateInput
CategorySumAggregateInput = CategoryNumberAggregateInput


CategoryCountAggregateInput = TypedDict(
    'CategoryCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'gender': bool,
        'level': bool,
        'minAge': bool,
        'maxAge': bool,
        'tournamentId': bool,
        '_all': bool,
    },
    total=False,
)

CategoryCountAggregateOutput = TypedDict(
    'CategoryCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'gender': int,
        'level': int,
        'minAge': int,
        'maxAge': int,
        'tournamentId': int,
        '_all': int,
    },
    total=False,
)


CategoryKeys = Literal[
    'id',
    'name',
    'gender',
    'level',
    'minAge',
    'maxAge',
    'tournamentId',
    'tournament',
    'participants',
    'teams',
    'matches',
]
CategoryScalarFieldKeys = Literal[
    'id',
    'name',
    'gender',
    'level',
    'minAge',
    'maxAge',
    'tournamentId',
]
CategoryScalarFieldKeysT = TypeVar('CategoryScalarFieldKeysT', bound=CategoryScalarFieldKeys)

CategoryRelationalFieldKeys = Literal[
        'tournament',
        'participants',
        'teams',
        'matches',
    ]

# Participant types

class ParticipantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Participant create method"""
    id: _int
    email: Optional[_str]
    phone: Optional[_str]
    isActive: _bool
    tournamentId: _int
    tournament: 'TournamentCreateNestedWithoutRelationsInput'
    categoryId: Optional[_int]
    category: 'CategoryCreateNestedWithoutRelationsInput'
    teamLinks: 'TeamParticipantCreateManyNestedWithoutRelationsInput'


class ParticipantCreateInput(ParticipantOptionalCreateInput):
    """Required arguments to the Participant create method"""
    fullName: _str
    birthDate: datetime.datetime
    gender: 'enums.Gender'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ParticipantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Participant create method, without relations"""
    id: _int
    email: Optional[_str]
    phone: Optional[_str]
    isActive: _bool
    tournamentId: _int
    categoryId: Optional[_int]


class ParticipantCreateWithoutRelationsInput(ParticipantOptionalCreateWithoutRelationsInput):
    """Required arguments to the Participant create method, without relations"""
    fullName: _str
    birthDate: datetime.datetime
    gender: 'enums.Gender'

class ParticipantConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ParticipantCreateWithoutRelationsInput'
    where: 'ParticipantWhereUniqueInput'

class ParticipantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ParticipantCreateWithoutRelationsInput'
    connect: 'ParticipantWhereUniqueInput'
    connect_or_create: 'ParticipantConnectOrCreateWithoutRelationsInput'


class ParticipantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ParticipantCreateWithoutRelationsInput', List['ParticipantCreateWithoutRelationsInput']]
    connect: Union['ParticipantWhereUniqueInput', List['ParticipantWhereUniqueInput']]
    connect_or_create: Union['ParticipantConnectOrCreateWithoutRelationsInput', List['ParticipantConnectOrCreateWithoutRelationsInput']]

_ParticipantWhereUnique_id_Input = TypedDict(
    '_ParticipantWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

ParticipantWhereUniqueInput = _ParticipantWhereUnique_id_Input


class ParticipantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    fullName: _str
    birthDate: datetime.datetime
    gender: 'enums.Gender'
    email: Optional[_str]
    phone: Optional[_str]
    isActive: _bool
    tournament: 'TournamentUpdateOneWithoutRelationsInput'
    category: 'CategoryUpdateOneWithoutRelationsInput'
    teamLinks: 'TeamParticipantUpdateManyWithoutRelationsInput'


class ParticipantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    fullName: _str
    birthDate: datetime.datetime
    gender: 'enums.Gender'
    email: Optional[_str]
    phone: Optional[_str]
    isActive: _bool


class ParticipantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ParticipantCreateWithoutRelationsInput']
    connect: List['ParticipantWhereUniqueInput']
    connect_or_create: List['ParticipantConnectOrCreateWithoutRelationsInput']
    set: List['ParticipantWhereUniqueInput']
    disconnect: List['ParticipantWhereUniqueInput']
    delete: List['ParticipantWhereUniqueInput']

    # TODO
    # update: List['ParticipantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ParticipantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ParticipantScalarWhereInput']
    # upsert: List['ParticipantUpserteWithWhereUniqueWithoutRelationsInput']


class ParticipantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ParticipantCreateWithoutRelationsInput'
    connect: 'ParticipantWhereUniqueInput'
    connect_or_create: 'ParticipantConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ParticipantUpdateInput'
    # upsert: 'ParticipantUpsertWithoutRelationsInput'


class ParticipantUpsertInput(TypedDict):
    create: 'ParticipantCreateInput'
    update: 'ParticipantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Participant_id_OrderByInput = TypedDict(
    '_Participant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Participant_fullName_OrderByInput = TypedDict(
    '_Participant_fullName_OrderByInput',
    {
        'fullName': 'SortOrder',
    },
    total=True
)

_Participant_birthDate_OrderByInput = TypedDict(
    '_Participant_birthDate_OrderByInput',
    {
        'birthDate': 'SortOrder',
    },
    total=True
)

_Participant_gender_OrderByInput = TypedDict(
    '_Participant_gender_OrderByInput',
    {
        'gender': 'SortOrder',
    },
    total=True
)

_Participant_email_OrderByInput = TypedDict(
    '_Participant_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Participant_phone_OrderByInput = TypedDict(
    '_Participant_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Participant_isActive_OrderByInput = TypedDict(
    '_Participant_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_Participant_tournamentId_OrderByInput = TypedDict(
    '_Participant_tournamentId_OrderByInput',
    {
        'tournamentId': 'SortOrder',
    },
    total=True
)

_Participant_categoryId_OrderByInput = TypedDict(
    '_Participant_categoryId_OrderByInput',
    {
        'categoryId': 'SortOrder',
    },
    total=True
)

_Participant_RelevanceInner = TypedDict(
    '_Participant_RelevanceInner',
    {
        'fields': 'List[ParticipantScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Participant_RelevanceOrderByInput = TypedDict(
    '_Participant_RelevanceOrderByInput',
    {
        '_relevance': '_Participant_RelevanceInner',
    },
    total=True
)

ParticipantOrderByInput = Union[
    '_Participant_id_OrderByInput',
    '_Participant_fullName_OrderByInput',
    '_Participant_birthDate_OrderByInput',
    '_Participant_gender_OrderByInput',
    '_Participant_email_OrderByInput',
    '_Participant_phone_OrderByInput',
    '_Participant_isActive_OrderByInput',
    '_Participant_tournamentId_OrderByInput',
    '_Participant_categoryId_OrderByInput',
    '_Participant_RelevanceOrderByInput',
]



# recursive Participant types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ParticipantRelationFilter = TypedDict(
    'ParticipantRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ParticipantListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ParticipantInclude(TypedDict, total=False):
    """Participant relational arguments"""
    tournament: Union[bool, 'TournamentArgsFromParticipant']
    category: Union[bool, 'CategoryArgsFromParticipant']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromParticipant']


    

class UserIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromParticipantRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromParticipantRecursive1']


class UserIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromParticipantRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromParticipantRecursive2']


class UserIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromParticipantRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromParticipantRecursive3']


class UserIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromParticipantRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromParticipantRecursive4']


class UserIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class UserArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyUserArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    createdBy: Union[bool, 'UserArgsFromParticipantRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromParticipantRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromParticipantRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive1']


class TournamentIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    createdBy: Union[bool, 'UserArgsFromParticipantRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromParticipantRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromParticipantRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive2']


class TournamentIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    createdBy: Union[bool, 'UserArgsFromParticipantRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromParticipantRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromParticipantRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive3']


class TournamentIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    createdBy: Union[bool, 'UserArgsFromParticipantRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromParticipantRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromParticipantRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive4']


class TournamentIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class TournamentArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyTournamentArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive1']


class CategoryIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive2']


class CategoryIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive3']


class CategoryIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromParticipantRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromParticipantRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive4']


class CategoryIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class CategoryArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyCategoryArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive1']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive1']


class ParticipantIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive2']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive2']


class ParticipantIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive3']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive3']


class ParticipantIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive4']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive4']


class ParticipantIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class ParticipantArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyParticipantArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive1']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromParticipantRecursive1']


class TeamIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive2']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromParticipantRecursive2']


class TeamIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive3']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromParticipantRecursive3']


class TeamIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive4']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromParticipantRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromParticipantRecursive4']


class TeamIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class TeamArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyTeamArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    team: Union[bool, 'TeamArgsFromParticipantRecursive1']
    participant: Union[bool, 'ParticipantArgsFromParticipantRecursive1']


class TeamParticipantIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    team: Union[bool, 'TeamArgsFromParticipantRecursive2']
    participant: Union[bool, 'ParticipantArgsFromParticipantRecursive2']


class TeamParticipantIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    team: Union[bool, 'TeamArgsFromParticipantRecursive3']
    participant: Union[bool, 'ParticipantArgsFromParticipantRecursive3']


class TeamParticipantIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    team: Union[bool, 'TeamArgsFromParticipantRecursive4']
    participant: Union[bool, 'ParticipantArgsFromParticipantRecursive4']


class TeamParticipantIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class TeamParticipantArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyTeamParticipantArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive1']


class CourtIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive2']


class CourtIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive3']


class CourtIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromParticipantRecursive4']


class CourtIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class CourtArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyCourtArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromParticipant(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive1']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive1']
    court: Union[bool, 'CourtArgsFromParticipantRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromParticipantRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromParticipantRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromParticipantRecursive1']
    referee: Union[bool, 'UserArgsFromParticipantRecursive1']


class MatchIncludeFromParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive2']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive2']
    court: Union[bool, 'CourtArgsFromParticipantRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromParticipantRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromParticipantRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromParticipantRecursive2']
    referee: Union[bool, 'UserArgsFromParticipantRecursive2']


class MatchIncludeFromParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive3']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive3']
    court: Union[bool, 'CourtArgsFromParticipantRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromParticipantRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromParticipantRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromParticipantRecursive3']
    referee: Union[bool, 'UserArgsFromParticipantRecursive3']


class MatchIncludeFromParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for Participant"""
    tournament: Union[bool, 'TournamentArgsFromParticipantRecursive4']
    category: Union[bool, 'CategoryArgsFromParticipantRecursive4']
    court: Union[bool, 'CourtArgsFromParticipantRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromParticipantRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromParticipantRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromParticipantRecursive4']
    referee: Union[bool, 'UserArgsFromParticipantRecursive4']


class MatchIncludeFromParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for Participant"""

    

class MatchArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    
    

class FindManyMatchArgsFromParticipant(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromParticipantRecursive1(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromParticipantRecursive2(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromParticipantRecursive3(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromParticipantRecursive4(TypedDict, total=False):
    """Arguments for Participant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyParticipantArgs = FindManyParticipantArgsFromParticipant
FindFirstParticipantArgs = FindManyParticipantArgsFromParticipant


    

class ParticipantWhereInput(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    fullName: Union[_str, 'types.StringFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeFilter']
    gender: 'enums.Gender'
    email: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[None, _int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    teamLinks: 'TeamParticipantListRelationFilter'

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive1', List['ParticipantWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive1']
    OR: List['ParticipantWhereInputRecursive1']
    NOT: List['ParticipantWhereInputRecursive1']


class ParticipantWhereInputRecursive1(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    fullName: Union[_str, 'types.StringFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeFilter']
    gender: 'enums.Gender'
    email: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[None, _int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    teamLinks: 'TeamParticipantListRelationFilter'

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive2', List['ParticipantWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive2']
    OR: List['ParticipantWhereInputRecursive2']
    NOT: List['ParticipantWhereInputRecursive2']


class ParticipantWhereInputRecursive2(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    fullName: Union[_str, 'types.StringFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeFilter']
    gender: 'enums.Gender'
    email: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[None, _int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    teamLinks: 'TeamParticipantListRelationFilter'

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive3', List['ParticipantWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive3']
    OR: List['ParticipantWhereInputRecursive3']
    NOT: List['ParticipantWhereInputRecursive3']


class ParticipantWhereInputRecursive3(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    fullName: Union[_str, 'types.StringFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeFilter']
    gender: 'enums.Gender'
    email: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[None, _int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    teamLinks: 'TeamParticipantListRelationFilter'

    # should be noted that AND and NOT should be Union['ParticipantWhereInputRecursive4', List['ParticipantWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ParticipantWhereInputRecursive4']
    OR: List['ParticipantWhereInputRecursive4']
    NOT: List['ParticipantWhereInputRecursive4']


class ParticipantWhereInputRecursive4(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    fullName: Union[_str, 'types.StringFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeFilter']
    gender: 'enums.Gender'
    email: Union[None, _str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[None, _int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    teamLinks: 'TeamParticipantListRelationFilter'



# aggregate Participant types


    

class ParticipantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gender: 'enums.Gender'
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive1']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive1']


class ParticipantScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gender: 'enums.Gender'
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive2']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive2']


class ParticipantScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gender: 'enums.Gender'
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive3']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive3']


class ParticipantScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gender: 'enums.Gender'
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ParticipantScalarWhereWithAggregatesInputRecursive4']
    OR: List['ParticipantScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ParticipantScalarWhereWithAggregatesInputRecursive4']


class ParticipantScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Participant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    birthDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gender: 'enums.Gender'
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']



class ParticipantGroupByOutput(TypedDict, total=False):
    id: _int
    fullName: _str
    birthDate: datetime.datetime
    gender: 'enums.Gender'
    email: _str
    phone: _str
    isActive: _bool
    tournamentId: _int
    categoryId: _int
    _sum: 'ParticipantSumAggregateOutput'
    _avg: 'ParticipantAvgAggregateOutput'
    _min: 'ParticipantMinAggregateOutput'
    _max: 'ParticipantMaxAggregateOutput'
    _count: 'ParticipantCountAggregateOutput'


class ParticipantAvgAggregateOutput(TypedDict, total=False):
    """Participant output for aggregating averages"""
    id: float
    tournamentId: float
    categoryId: float


class ParticipantSumAggregateOutput(TypedDict, total=False):
    """Participant output for aggregating sums"""
    id: _int
    tournamentId: _int
    categoryId: _int


class ParticipantScalarAggregateOutput(TypedDict, total=False):
    """Participant output including scalar fields"""
    id: _int
    fullName: _str
    birthDate: datetime.datetime
    gender: 'enums.Gender'
    email: _str
    phone: _str
    isActive: _bool
    tournamentId: _int
    categoryId: _int


ParticipantMinAggregateOutput = ParticipantScalarAggregateOutput
ParticipantMaxAggregateOutput = ParticipantScalarAggregateOutput


class ParticipantMaxAggregateInput(TypedDict, total=False):
    """Participant input for aggregating by max"""
    id: bool
    fullName: bool
    birthDate: bool
    gender: bool
    email: bool
    phone: bool
    isActive: bool
    tournamentId: bool
    categoryId: bool


class ParticipantMinAggregateInput(TypedDict, total=False):
    """Participant input for aggregating by min"""
    id: bool
    fullName: bool
    birthDate: bool
    gender: bool
    email: bool
    phone: bool
    isActive: bool
    tournamentId: bool
    categoryId: bool


class ParticipantNumberAggregateInput(TypedDict, total=False):
    """Participant input for aggregating numbers"""
    id: bool
    tournamentId: bool
    categoryId: bool


ParticipantAvgAggregateInput = ParticipantNumberAggregateInput
ParticipantSumAggregateInput = ParticipantNumberAggregateInput


ParticipantCountAggregateInput = TypedDict(
    'ParticipantCountAggregateInput',
    {
        'id': bool,
        'fullName': bool,
        'birthDate': bool,
        'gender': bool,
        'email': bool,
        'phone': bool,
        'isActive': bool,
        'tournamentId': bool,
        'categoryId': bool,
        '_all': bool,
    },
    total=False,
)

ParticipantCountAggregateOutput = TypedDict(
    'ParticipantCountAggregateOutput',
    {
        'id': int,
        'fullName': int,
        'birthDate': int,
        'gender': int,
        'email': int,
        'phone': int,
        'isActive': int,
        'tournamentId': int,
        'categoryId': int,
        '_all': int,
    },
    total=False,
)


ParticipantKeys = Literal[
    'id',
    'fullName',
    'birthDate',
    'gender',
    'email',
    'phone',
    'isActive',
    'tournamentId',
    'tournament',
    'categoryId',
    'category',
    'teamLinks',
]
ParticipantScalarFieldKeys = Literal[
    'id',
    'fullName',
    'birthDate',
    'gender',
    'email',
    'phone',
    'isActive',
    'tournamentId',
    'categoryId',
]
ParticipantScalarFieldKeysT = TypeVar('ParticipantScalarFieldKeysT', bound=ParticipantScalarFieldKeys)

ParticipantRelationalFieldKeys = Literal[
        'tournament',
        'category',
        'teamLinks',
    ]

# Team types

class TeamOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Team create method"""
    id: _int
    tournamentId: _int
    tournament: 'TournamentCreateNestedWithoutRelationsInput'
    categoryId: _int
    category: 'CategoryCreateNestedWithoutRelationsInput'
    players: 'TeamParticipantCreateManyNestedWithoutRelationsInput'
    homeMatches: 'MatchCreateManyNestedWithoutRelationsInput'
    awayMatches: 'MatchCreateManyNestedWithoutRelationsInput'
    winnerOf: 'MatchCreateManyNestedWithoutRelationsInput'


class TeamCreateInput(TeamOptionalCreateInput):
    """Required arguments to the Team create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Team create method, without relations"""
    id: _int
    tournamentId: _int
    categoryId: _int


class TeamCreateWithoutRelationsInput(TeamOptionalCreateWithoutRelationsInput):
    """Required arguments to the Team create method, without relations"""
    name: _str

class TeamConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TeamCreateWithoutRelationsInput'
    where: 'TeamWhereUniqueInput'

class TeamCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'
    connect_or_create: 'TeamConnectOrCreateWithoutRelationsInput'


class TeamCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamCreateWithoutRelationsInput', List['TeamCreateWithoutRelationsInput']]
    connect: Union['TeamWhereUniqueInput', List['TeamWhereUniqueInput']]
    connect_or_create: Union['TeamConnectOrCreateWithoutRelationsInput', List['TeamConnectOrCreateWithoutRelationsInput']]

_TeamWhereUnique_id_Input = TypedDict(
    '_TeamWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

TeamWhereUniqueInput = _TeamWhereUnique_id_Input


class TeamUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    tournament: 'TournamentUpdateOneWithoutRelationsInput'
    category: 'CategoryUpdateOneWithoutRelationsInput'
    players: 'TeamParticipantUpdateManyWithoutRelationsInput'
    homeMatches: 'MatchUpdateManyWithoutRelationsInput'
    awayMatches: 'MatchUpdateManyWithoutRelationsInput'
    winnerOf: 'MatchUpdateManyWithoutRelationsInput'


class TeamUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str


class TeamUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamCreateWithoutRelationsInput']
    connect: List['TeamWhereUniqueInput']
    connect_or_create: List['TeamConnectOrCreateWithoutRelationsInput']
    set: List['TeamWhereUniqueInput']
    disconnect: List['TeamWhereUniqueInput']
    delete: List['TeamWhereUniqueInput']

    # TODO
    # update: List['TeamUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamScalarWhereInput']
    # upsert: List['TeamUpserteWithWhereUniqueWithoutRelationsInput']


class TeamUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamCreateWithoutRelationsInput'
    connect: 'TeamWhereUniqueInput'
    connect_or_create: 'TeamConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamUpdateInput'
    # upsert: 'TeamUpsertWithoutRelationsInput'


class TeamUpsertInput(TypedDict):
    create: 'TeamCreateInput'
    update: 'TeamUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Team_id_OrderByInput = TypedDict(
    '_Team_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Team_name_OrderByInput = TypedDict(
    '_Team_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Team_tournamentId_OrderByInput = TypedDict(
    '_Team_tournamentId_OrderByInput',
    {
        'tournamentId': 'SortOrder',
    },
    total=True
)

_Team_categoryId_OrderByInput = TypedDict(
    '_Team_categoryId_OrderByInput',
    {
        'categoryId': 'SortOrder',
    },
    total=True
)

_Team_RelevanceInner = TypedDict(
    '_Team_RelevanceInner',
    {
        'fields': 'List[TeamScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Team_RelevanceOrderByInput = TypedDict(
    '_Team_RelevanceOrderByInput',
    {
        '_relevance': '_Team_RelevanceInner',
    },
    total=True
)

TeamOrderByInput = Union[
    '_Team_id_OrderByInput',
    '_Team_name_OrderByInput',
    '_Team_tournamentId_OrderByInput',
    '_Team_categoryId_OrderByInput',
    '_Team_RelevanceOrderByInput',
]



# recursive Team types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TeamRelationFilter = TypedDict(
    'TeamRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TeamListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TeamInclude(TypedDict, total=False):
    """Team relational arguments"""
    tournament: Union[bool, 'TournamentArgsFromTeam']
    category: Union[bool, 'CategoryArgsFromTeam']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeam']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeam']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeam']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeam']


    

class UserIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamRecursive1']


class UserIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamRecursive2']


class UserIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamRecursive3']


class UserIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamRecursive4']


class UserIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class UserArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyUserArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    createdBy: Union[bool, 'UserArgsFromTeamRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromTeamRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive1']


class TournamentIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    createdBy: Union[bool, 'UserArgsFromTeamRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromTeamRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive2']


class TournamentIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    createdBy: Union[bool, 'UserArgsFromTeamRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromTeamRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive3']


class TournamentIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    createdBy: Union[bool, 'UserArgsFromTeamRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromTeamRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive4']


class TournamentIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class TournamentArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyTournamentArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive1']


class CategoryIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive2']


class CategoryIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive3']


class CategoryIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTeamRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive4']


class CategoryIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class CategoryArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyCategoryArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive1']
    category: Union[bool, 'CategoryArgsFromTeamRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive1']


class ParticipantIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive2']
    category: Union[bool, 'CategoryArgsFromTeamRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive2']


class ParticipantIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive3']
    category: Union[bool, 'CategoryArgsFromTeamRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive3']


class ParticipantIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive4']
    category: Union[bool, 'CategoryArgsFromTeamRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive4']


class ParticipantIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class ParticipantArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyParticipantArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive1']
    category: Union[bool, 'CategoryArgsFromTeamRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamRecursive1']


class TeamIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive2']
    category: Union[bool, 'CategoryArgsFromTeamRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamRecursive2']


class TeamIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive3']
    category: Union[bool, 'CategoryArgsFromTeamRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamRecursive3']


class TeamIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive4']
    category: Union[bool, 'CategoryArgsFromTeamRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamRecursive4']


class TeamIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class TeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyTeamArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    team: Union[bool, 'TeamArgsFromTeamRecursive1']
    participant: Union[bool, 'ParticipantArgsFromTeamRecursive1']


class TeamParticipantIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    team: Union[bool, 'TeamArgsFromTeamRecursive2']
    participant: Union[bool, 'ParticipantArgsFromTeamRecursive2']


class TeamParticipantIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    team: Union[bool, 'TeamArgsFromTeamRecursive3']
    participant: Union[bool, 'ParticipantArgsFromTeamRecursive3']


class TeamParticipantIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    team: Union[bool, 'TeamArgsFromTeamRecursive4']
    participant: Union[bool, 'ParticipantArgsFromTeamRecursive4']


class TeamParticipantIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class TeamParticipantArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyTeamParticipantArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive1']


class CourtIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive2']


class CourtIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive3']


class CourtIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTeamRecursive4']


class CourtIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class CourtArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyCourtArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromTeam(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive1']
    category: Union[bool, 'CategoryArgsFromTeamRecursive1']
    court: Union[bool, 'CourtArgsFromTeamRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromTeamRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromTeamRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromTeamRecursive1']
    referee: Union[bool, 'UserArgsFromTeamRecursive1']


class MatchIncludeFromTeamRecursive1(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive2']
    category: Union[bool, 'CategoryArgsFromTeamRecursive2']
    court: Union[bool, 'CourtArgsFromTeamRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromTeamRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromTeamRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromTeamRecursive2']
    referee: Union[bool, 'UserArgsFromTeamRecursive2']


class MatchIncludeFromTeamRecursive2(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive3']
    category: Union[bool, 'CategoryArgsFromTeamRecursive3']
    court: Union[bool, 'CourtArgsFromTeamRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromTeamRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromTeamRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromTeamRecursive3']
    referee: Union[bool, 'UserArgsFromTeamRecursive3']


class MatchIncludeFromTeamRecursive3(TypedDict, total=False):
    """Relational arguments for Team"""
    tournament: Union[bool, 'TournamentArgsFromTeamRecursive4']
    category: Union[bool, 'CategoryArgsFromTeamRecursive4']
    court: Union[bool, 'CourtArgsFromTeamRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromTeamRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromTeamRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromTeamRecursive4']
    referee: Union[bool, 'UserArgsFromTeamRecursive4']


class MatchIncludeFromTeamRecursive4(TypedDict, total=False):
    """Relational arguments for Team"""

    

class MatchArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    
    

class FindManyMatchArgsFromTeam(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromTeamRecursive1(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromTeamRecursive2(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromTeamRecursive3(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromTeamRecursive4(TypedDict, total=False):
    """Arguments for Team"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyTeamArgs = FindManyTeamArgsFromTeam
FindFirstTeamArgs = FindManyTeamArgsFromTeam


    

class TeamWhereInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    players: 'TeamParticipantListRelationFilter'
    homeMatches: 'MatchListRelationFilter'
    awayMatches: 'MatchListRelationFilter'
    winnerOf: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive1', List['TeamWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive1']
    OR: List['TeamWhereInputRecursive1']
    NOT: List['TeamWhereInputRecursive1']


class TeamWhereInputRecursive1(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    players: 'TeamParticipantListRelationFilter'
    homeMatches: 'MatchListRelationFilter'
    awayMatches: 'MatchListRelationFilter'
    winnerOf: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive2', List['TeamWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive2']
    OR: List['TeamWhereInputRecursive2']
    NOT: List['TeamWhereInputRecursive2']


class TeamWhereInputRecursive2(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    players: 'TeamParticipantListRelationFilter'
    homeMatches: 'MatchListRelationFilter'
    awayMatches: 'MatchListRelationFilter'
    winnerOf: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive3', List['TeamWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive3']
    OR: List['TeamWhereInputRecursive3']
    NOT: List['TeamWhereInputRecursive3']


class TeamWhereInputRecursive3(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    players: 'TeamParticipantListRelationFilter'
    homeMatches: 'MatchListRelationFilter'
    awayMatches: 'MatchListRelationFilter'
    winnerOf: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['TeamWhereInputRecursive4', List['TeamWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TeamWhereInputRecursive4']
    OR: List['TeamWhereInputRecursive4']
    NOT: List['TeamWhereInputRecursive4']


class TeamWhereInputRecursive4(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    players: 'TeamParticipantListRelationFilter'
    homeMatches: 'MatchListRelationFilter'
    awayMatches: 'MatchListRelationFilter'
    winnerOf: 'MatchListRelationFilter'



# aggregate Team types


    

class TeamScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive1']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive1']


class TeamScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive2']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive2']


class TeamScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive3']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive3']


class TeamScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamScalarWhereWithAggregatesInputRecursive4']
    OR: List['TeamScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TeamScalarWhereWithAggregatesInputRecursive4']


class TeamScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Team arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']



class TeamGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    tournamentId: _int
    categoryId: _int
    _sum: 'TeamSumAggregateOutput'
    _avg: 'TeamAvgAggregateOutput'
    _min: 'TeamMinAggregateOutput'
    _max: 'TeamMaxAggregateOutput'
    _count: 'TeamCountAggregateOutput'


class TeamAvgAggregateOutput(TypedDict, total=False):
    """Team output for aggregating averages"""
    id: float
    tournamentId: float
    categoryId: float


class TeamSumAggregateOutput(TypedDict, total=False):
    """Team output for aggregating sums"""
    id: _int
    tournamentId: _int
    categoryId: _int


class TeamScalarAggregateOutput(TypedDict, total=False):
    """Team output including scalar fields"""
    id: _int
    name: _str
    tournamentId: _int
    categoryId: _int


TeamMinAggregateOutput = TeamScalarAggregateOutput
TeamMaxAggregateOutput = TeamScalarAggregateOutput


class TeamMaxAggregateInput(TypedDict, total=False):
    """Team input for aggregating by max"""
    id: bool
    name: bool
    tournamentId: bool
    categoryId: bool


class TeamMinAggregateInput(TypedDict, total=False):
    """Team input for aggregating by min"""
    id: bool
    name: bool
    tournamentId: bool
    categoryId: bool


class TeamNumberAggregateInput(TypedDict, total=False):
    """Team input for aggregating numbers"""
    id: bool
    tournamentId: bool
    categoryId: bool


TeamAvgAggregateInput = TeamNumberAggregateInput
TeamSumAggregateInput = TeamNumberAggregateInput


TeamCountAggregateInput = TypedDict(
    'TeamCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'tournamentId': bool,
        'categoryId': bool,
        '_all': bool,
    },
    total=False,
)

TeamCountAggregateOutput = TypedDict(
    'TeamCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'tournamentId': int,
        'categoryId': int,
        '_all': int,
    },
    total=False,
)


TeamKeys = Literal[
    'id',
    'name',
    'tournamentId',
    'tournament',
    'categoryId',
    'category',
    'players',
    'homeMatches',
    'awayMatches',
    'winnerOf',
]
TeamScalarFieldKeys = Literal[
    'id',
    'name',
    'tournamentId',
    'categoryId',
]
TeamScalarFieldKeysT = TypeVar('TeamScalarFieldKeysT', bound=TeamScalarFieldKeys)

TeamRelationalFieldKeys = Literal[
        'tournament',
        'category',
        'players',
        'homeMatches',
        'awayMatches',
        'winnerOf',
    ]

# TeamParticipant types

class TeamParticipantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the TeamParticipant create method"""
    id: _int
    teamId: _int
    participantId: _int
    team: 'TeamCreateNestedWithoutRelationsInput'
    participant: 'ParticipantCreateNestedWithoutRelationsInput'


class TeamParticipantCreateInput(TeamParticipantOptionalCreateInput):
    """Required arguments to the TeamParticipant create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TeamParticipantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the TeamParticipant create method, without relations"""
    id: _int
    teamId: _int
    participantId: _int


class TeamParticipantCreateWithoutRelationsInput(TeamParticipantOptionalCreateWithoutRelationsInput):
    """Required arguments to the TeamParticipant create method, without relations"""

class TeamParticipantConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TeamParticipantCreateWithoutRelationsInput'
    where: 'TeamParticipantWhereUniqueInput'

class TeamParticipantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamParticipantCreateWithoutRelationsInput'
    connect: 'TeamParticipantWhereUniqueInput'
    connect_or_create: 'TeamParticipantConnectOrCreateWithoutRelationsInput'


class TeamParticipantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TeamParticipantCreateWithoutRelationsInput', List['TeamParticipantCreateWithoutRelationsInput']]
    connect: Union['TeamParticipantWhereUniqueInput', List['TeamParticipantWhereUniqueInput']]
    connect_or_create: Union['TeamParticipantConnectOrCreateWithoutRelationsInput', List['TeamParticipantConnectOrCreateWithoutRelationsInput']]

_TeamParticipantWhereUnique_id_Input = TypedDict(
    '_TeamParticipantWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_TeamParticipantCompoundteamId_participantIdKeyInner = TypedDict(
    '_TeamParticipantCompoundteamId_participantIdKeyInner',
    {
        'teamId': '_int',
        'participantId': '_int',
    },
    total=True
)

_TeamParticipantCompoundteamId_participantIdKey = TypedDict(
    '_TeamParticipantCompoundteamId_participantIdKey',
    {
        'teamId_participantId': '_TeamParticipantCompoundteamId_participantIdKeyInner',
    },
    total=True
)

TeamParticipantWhereUniqueInput = Union[
    '_TeamParticipantWhereUnique_id_Input',
    '_TeamParticipantCompoundteamId_participantIdKey',
]


class TeamParticipantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    team: 'TeamUpdateOneWithoutRelationsInput'
    participant: 'ParticipantUpdateOneWithoutRelationsInput'


class TeamParticipantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]


class TeamParticipantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TeamParticipantCreateWithoutRelationsInput']
    connect: List['TeamParticipantWhereUniqueInput']
    connect_or_create: List['TeamParticipantConnectOrCreateWithoutRelationsInput']
    set: List['TeamParticipantWhereUniqueInput']
    disconnect: List['TeamParticipantWhereUniqueInput']
    delete: List['TeamParticipantWhereUniqueInput']

    # TODO
    # update: List['TeamParticipantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TeamParticipantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TeamParticipantScalarWhereInput']
    # upsert: List['TeamParticipantUpserteWithWhereUniqueWithoutRelationsInput']


class TeamParticipantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TeamParticipantCreateWithoutRelationsInput'
    connect: 'TeamParticipantWhereUniqueInput'
    connect_or_create: 'TeamParticipantConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TeamParticipantUpdateInput'
    # upsert: 'TeamParticipantUpsertWithoutRelationsInput'


class TeamParticipantUpsertInput(TypedDict):
    create: 'TeamParticipantCreateInput'
    update: 'TeamParticipantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_TeamParticipant_id_OrderByInput = TypedDict(
    '_TeamParticipant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_TeamParticipant_teamId_OrderByInput = TypedDict(
    '_TeamParticipant_teamId_OrderByInput',
    {
        'teamId': 'SortOrder',
    },
    total=True
)

_TeamParticipant_participantId_OrderByInput = TypedDict(
    '_TeamParticipant_participantId_OrderByInput',
    {
        'participantId': 'SortOrder',
    },
    total=True
)

_TeamParticipant_RelevanceInner = TypedDict(
    '_TeamParticipant_RelevanceInner',
    {
        'fields': 'List[TeamParticipantScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_TeamParticipant_RelevanceOrderByInput = TypedDict(
    '_TeamParticipant_RelevanceOrderByInput',
    {
        '_relevance': '_TeamParticipant_RelevanceInner',
    },
    total=True
)

TeamParticipantOrderByInput = Union[
    '_TeamParticipant_id_OrderByInput',
    '_TeamParticipant_teamId_OrderByInput',
    '_TeamParticipant_participantId_OrderByInput',
    '_TeamParticipant_RelevanceOrderByInput',
]



# recursive TeamParticipant types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TeamParticipantRelationFilter = TypedDict(
    'TeamParticipantRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TeamParticipantListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TeamParticipantInclude(TypedDict, total=False):
    """TeamParticipant relational arguments"""
    team: Union[bool, 'TeamArgsFromTeamParticipant']
    participant: Union[bool, 'ParticipantArgsFromTeamParticipant']


    

class UserIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamParticipantRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive1']


class UserIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamParticipantRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive2']


class UserIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamParticipantRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive3']


class UserIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromTeamParticipantRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive4']


class UserIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class UserArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyUserArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    createdBy: Union[bool, 'UserArgsFromTeamParticipantRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamParticipantRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromTeamParticipantRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive1']


class TournamentIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    createdBy: Union[bool, 'UserArgsFromTeamParticipantRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamParticipantRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromTeamParticipantRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive2']


class TournamentIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    createdBy: Union[bool, 'UserArgsFromTeamParticipantRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamParticipantRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromTeamParticipantRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive3']


class TournamentIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    createdBy: Union[bool, 'UserArgsFromTeamParticipantRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromTeamParticipantRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromTeamParticipantRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive4']


class TournamentIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class TournamentArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyTournamentArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive1']


class CategoryIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive2']


class CategoryIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive3']


class CategoryIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromTeamParticipantRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromTeamParticipantRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive4']


class CategoryIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class CategoryArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyCategoryArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive1']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive1']


class ParticipantIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive2']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive2']


class ParticipantIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive3']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive3']


class ParticipantIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive4']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive4']


class ParticipantIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class ParticipantArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyParticipantArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive1']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive1']


class TeamIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive2']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive2']


class TeamIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive3']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive3']


class TeamIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive4']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromTeamParticipantRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive4']


class TeamIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class TeamArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyTeamArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    team: Union[bool, 'TeamArgsFromTeamParticipantRecursive1']
    participant: Union[bool, 'ParticipantArgsFromTeamParticipantRecursive1']


class TeamParticipantIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    team: Union[bool, 'TeamArgsFromTeamParticipantRecursive2']
    participant: Union[bool, 'ParticipantArgsFromTeamParticipantRecursive2']


class TeamParticipantIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    team: Union[bool, 'TeamArgsFromTeamParticipantRecursive3']
    participant: Union[bool, 'ParticipantArgsFromTeamParticipantRecursive3']


class TeamParticipantIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    team: Union[bool, 'TeamArgsFromTeamParticipantRecursive4']
    participant: Union[bool, 'ParticipantArgsFromTeamParticipantRecursive4']


class TeamParticipantIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class TeamParticipantArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyTeamParticipantArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive1']


class CourtIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive2']


class CourtIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive3']


class CourtIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromTeamParticipantRecursive4']


class CourtIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class CourtArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyCourtArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromTeamParticipant(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive1']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive1']
    court: Union[bool, 'CourtArgsFromTeamParticipantRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive1']
    referee: Union[bool, 'UserArgsFromTeamParticipantRecursive1']


class MatchIncludeFromTeamParticipantRecursive1(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive2']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive2']
    court: Union[bool, 'CourtArgsFromTeamParticipantRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive2']
    referee: Union[bool, 'UserArgsFromTeamParticipantRecursive2']


class MatchIncludeFromTeamParticipantRecursive2(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive3']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive3']
    court: Union[bool, 'CourtArgsFromTeamParticipantRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive3']
    referee: Union[bool, 'UserArgsFromTeamParticipantRecursive3']


class MatchIncludeFromTeamParticipantRecursive3(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""
    tournament: Union[bool, 'TournamentArgsFromTeamParticipantRecursive4']
    category: Union[bool, 'CategoryArgsFromTeamParticipantRecursive4']
    court: Union[bool, 'CourtArgsFromTeamParticipantRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromTeamParticipantRecursive4']
    referee: Union[bool, 'UserArgsFromTeamParticipantRecursive4']


class MatchIncludeFromTeamParticipantRecursive4(TypedDict, total=False):
    """Relational arguments for TeamParticipant"""

    

class MatchArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    
    

class FindManyMatchArgsFromTeamParticipant(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromTeamParticipantRecursive1(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromTeamParticipantRecursive2(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromTeamParticipantRecursive3(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromTeamParticipantRecursive4(TypedDict, total=False):
    """Arguments for TeamParticipant"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyTeamParticipantArgs = FindManyTeamParticipantArgsFromTeamParticipant
FindFirstTeamParticipantArgs = FindManyTeamParticipantArgsFromTeamParticipant


    

class TeamParticipantWhereInput(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    teamId: Union[_int, 'types.IntFilter']
    participantId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    participant: 'ParticipantRelationFilter'

    # should be noted that AND and NOT should be Union['TeamParticipantWhereInputRecursive1', List['TeamParticipantWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TeamParticipantWhereInputRecursive1']
    OR: List['TeamParticipantWhereInputRecursive1']
    NOT: List['TeamParticipantWhereInputRecursive1']


class TeamParticipantWhereInputRecursive1(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    teamId: Union[_int, 'types.IntFilter']
    participantId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    participant: 'ParticipantRelationFilter'

    # should be noted that AND and NOT should be Union['TeamParticipantWhereInputRecursive2', List['TeamParticipantWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TeamParticipantWhereInputRecursive2']
    OR: List['TeamParticipantWhereInputRecursive2']
    NOT: List['TeamParticipantWhereInputRecursive2']


class TeamParticipantWhereInputRecursive2(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    teamId: Union[_int, 'types.IntFilter']
    participantId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    participant: 'ParticipantRelationFilter'

    # should be noted that AND and NOT should be Union['TeamParticipantWhereInputRecursive3', List['TeamParticipantWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TeamParticipantWhereInputRecursive3']
    OR: List['TeamParticipantWhereInputRecursive3']
    NOT: List['TeamParticipantWhereInputRecursive3']


class TeamParticipantWhereInputRecursive3(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    teamId: Union[_int, 'types.IntFilter']
    participantId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    participant: 'ParticipantRelationFilter'

    # should be noted that AND and NOT should be Union['TeamParticipantWhereInputRecursive4', List['TeamParticipantWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TeamParticipantWhereInputRecursive4']
    OR: List['TeamParticipantWhereInputRecursive4']
    NOT: List['TeamParticipantWhereInputRecursive4']


class TeamParticipantWhereInputRecursive4(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    teamId: Union[_int, 'types.IntFilter']
    participantId: Union[_int, 'types.IntFilter']
    team: 'TeamRelationFilter'
    participant: 'ParticipantRelationFilter'



# aggregate TeamParticipant types


    

class TeamParticipantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    participantId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamParticipantScalarWhereWithAggregatesInputRecursive1']
    OR: List['TeamParticipantScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TeamParticipantScalarWhereWithAggregatesInputRecursive1']


class TeamParticipantScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    participantId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamParticipantScalarWhereWithAggregatesInputRecursive2']
    OR: List['TeamParticipantScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TeamParticipantScalarWhereWithAggregatesInputRecursive2']


class TeamParticipantScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    participantId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamParticipantScalarWhereWithAggregatesInputRecursive3']
    OR: List['TeamParticipantScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TeamParticipantScalarWhereWithAggregatesInputRecursive3']


class TeamParticipantScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    participantId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['TeamParticipantScalarWhereWithAggregatesInputRecursive4']
    OR: List['TeamParticipantScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TeamParticipantScalarWhereWithAggregatesInputRecursive4']


class TeamParticipantScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """TeamParticipant arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    teamId: Union[_int, 'types.IntWithAggregatesFilter']
    participantId: Union[_int, 'types.IntWithAggregatesFilter']



class TeamParticipantGroupByOutput(TypedDict, total=False):
    id: _int
    teamId: _int
    participantId: _int
    _sum: 'TeamParticipantSumAggregateOutput'
    _avg: 'TeamParticipantAvgAggregateOutput'
    _min: 'TeamParticipantMinAggregateOutput'
    _max: 'TeamParticipantMaxAggregateOutput'
    _count: 'TeamParticipantCountAggregateOutput'


class TeamParticipantAvgAggregateOutput(TypedDict, total=False):
    """TeamParticipant output for aggregating averages"""
    id: float
    teamId: float
    participantId: float


class TeamParticipantSumAggregateOutput(TypedDict, total=False):
    """TeamParticipant output for aggregating sums"""
    id: _int
    teamId: _int
    participantId: _int


class TeamParticipantScalarAggregateOutput(TypedDict, total=False):
    """TeamParticipant output including scalar fields"""
    id: _int
    teamId: _int
    participantId: _int


TeamParticipantMinAggregateOutput = TeamParticipantScalarAggregateOutput
TeamParticipantMaxAggregateOutput = TeamParticipantScalarAggregateOutput


class TeamParticipantMaxAggregateInput(TypedDict, total=False):
    """TeamParticipant input for aggregating by max"""
    id: bool
    teamId: bool
    participantId: bool


class TeamParticipantMinAggregateInput(TypedDict, total=False):
    """TeamParticipant input for aggregating by min"""
    id: bool
    teamId: bool
    participantId: bool


class TeamParticipantNumberAggregateInput(TypedDict, total=False):
    """TeamParticipant input for aggregating numbers"""
    id: bool
    teamId: bool
    participantId: bool


TeamParticipantAvgAggregateInput = TeamParticipantNumberAggregateInput
TeamParticipantSumAggregateInput = TeamParticipantNumberAggregateInput


TeamParticipantCountAggregateInput = TypedDict(
    'TeamParticipantCountAggregateInput',
    {
        'id': bool,
        'teamId': bool,
        'participantId': bool,
        '_all': bool,
    },
    total=False,
)

TeamParticipantCountAggregateOutput = TypedDict(
    'TeamParticipantCountAggregateOutput',
    {
        'id': int,
        'teamId': int,
        'participantId': int,
        '_all': int,
    },
    total=False,
)


TeamParticipantKeys = Literal[
    'id',
    'teamId',
    'participantId',
    'team',
    'participant',
]
TeamParticipantScalarFieldKeys = Literal[
    'id',
    'teamId',
    'participantId',
]
TeamParticipantScalarFieldKeysT = TypeVar('TeamParticipantScalarFieldKeysT', bound=TeamParticipantScalarFieldKeys)

TeamParticipantRelationalFieldKeys = Literal[
        'team',
        'participant',
    ]

# Court types

class CourtOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Court create method"""
    id: _int
    locationNote: Optional[_str]
    tournamentId: _int
    tournament: 'TournamentCreateNestedWithoutRelationsInput'
    matches: 'MatchCreateManyNestedWithoutRelationsInput'


class CourtCreateInput(CourtOptionalCreateInput):
    """Required arguments to the Court create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CourtOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Court create method, without relations"""
    id: _int
    locationNote: Optional[_str]
    tournamentId: _int


class CourtCreateWithoutRelationsInput(CourtOptionalCreateWithoutRelationsInput):
    """Required arguments to the Court create method, without relations"""
    name: _str

class CourtConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CourtCreateWithoutRelationsInput'
    where: 'CourtWhereUniqueInput'

class CourtCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CourtCreateWithoutRelationsInput'
    connect: 'CourtWhereUniqueInput'
    connect_or_create: 'CourtConnectOrCreateWithoutRelationsInput'


class CourtCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CourtCreateWithoutRelationsInput', List['CourtCreateWithoutRelationsInput']]
    connect: Union['CourtWhereUniqueInput', List['CourtWhereUniqueInput']]
    connect_or_create: Union['CourtConnectOrCreateWithoutRelationsInput', List['CourtConnectOrCreateWithoutRelationsInput']]

_CourtWhereUnique_id_Input = TypedDict(
    '_CourtWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

CourtWhereUniqueInput = _CourtWhereUnique_id_Input


class CourtUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    name: _str
    locationNote: Optional[_str]
    tournament: 'TournamentUpdateOneWithoutRelationsInput'
    matches: 'MatchUpdateManyWithoutRelationsInput'


class CourtUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    name: _str
    locationNote: Optional[_str]


class CourtUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CourtCreateWithoutRelationsInput']
    connect: List['CourtWhereUniqueInput']
    connect_or_create: List['CourtConnectOrCreateWithoutRelationsInput']
    set: List['CourtWhereUniqueInput']
    disconnect: List['CourtWhereUniqueInput']
    delete: List['CourtWhereUniqueInput']

    # TODO
    # update: List['CourtUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CourtUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CourtScalarWhereInput']
    # upsert: List['CourtUpserteWithWhereUniqueWithoutRelationsInput']


class CourtUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CourtCreateWithoutRelationsInput'
    connect: 'CourtWhereUniqueInput'
    connect_or_create: 'CourtConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CourtUpdateInput'
    # upsert: 'CourtUpsertWithoutRelationsInput'


class CourtUpsertInput(TypedDict):
    create: 'CourtCreateInput'
    update: 'CourtUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Court_id_OrderByInput = TypedDict(
    '_Court_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Court_name_OrderByInput = TypedDict(
    '_Court_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Court_locationNote_OrderByInput = TypedDict(
    '_Court_locationNote_OrderByInput',
    {
        'locationNote': 'SortOrder',
    },
    total=True
)

_Court_tournamentId_OrderByInput = TypedDict(
    '_Court_tournamentId_OrderByInput',
    {
        'tournamentId': 'SortOrder',
    },
    total=True
)

_Court_RelevanceInner = TypedDict(
    '_Court_RelevanceInner',
    {
        'fields': 'List[CourtScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Court_RelevanceOrderByInput = TypedDict(
    '_Court_RelevanceOrderByInput',
    {
        '_relevance': '_Court_RelevanceInner',
    },
    total=True
)

CourtOrderByInput = Union[
    '_Court_id_OrderByInput',
    '_Court_name_OrderByInput',
    '_Court_locationNote_OrderByInput',
    '_Court_tournamentId_OrderByInput',
    '_Court_RelevanceOrderByInput',
]



# recursive Court types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CourtRelationFilter = TypedDict(
    'CourtRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CourtListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CourtInclude(TypedDict, total=False):
    """Court relational arguments"""
    tournament: Union[bool, 'TournamentArgsFromCourt']
    matches: Union[bool, 'FindManyMatchArgsFromCourt']


    

class UserIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCourtRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCourtRecursive1']


class UserIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCourtRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCourtRecursive2']


class UserIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCourtRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCourtRecursive3']


class UserIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromCourtRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromCourtRecursive4']


class UserIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class UserArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyUserArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    createdBy: Union[bool, 'UserArgsFromCourtRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromCourtRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromCourtRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive1']


class TournamentIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    createdBy: Union[bool, 'UserArgsFromCourtRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromCourtRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromCourtRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive2']


class TournamentIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    createdBy: Union[bool, 'UserArgsFromCourtRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromCourtRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromCourtRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive3']


class TournamentIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    createdBy: Union[bool, 'UserArgsFromCourtRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromCourtRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromCourtRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive4']


class TournamentIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class TournamentArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyTournamentArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive1']


class CategoryIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive2']


class CategoryIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive3']


class CategoryIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromCourtRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromCourtRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive4']


class CategoryIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class CategoryArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyCategoryArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive1']
    category: Union[bool, 'CategoryArgsFromCourtRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive1']


class ParticipantIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive2']
    category: Union[bool, 'CategoryArgsFromCourtRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive2']


class ParticipantIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive3']
    category: Union[bool, 'CategoryArgsFromCourtRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive3']


class ParticipantIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive4']
    category: Union[bool, 'CategoryArgsFromCourtRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive4']


class ParticipantIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class ParticipantArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyParticipantArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive1']
    category: Union[bool, 'CategoryArgsFromCourtRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCourtRecursive1']


class TeamIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive2']
    category: Union[bool, 'CategoryArgsFromCourtRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCourtRecursive2']


class TeamIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive3']
    category: Union[bool, 'CategoryArgsFromCourtRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCourtRecursive3']


class TeamIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive4']
    category: Union[bool, 'CategoryArgsFromCourtRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromCourtRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromCourtRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromCourtRecursive4']


class TeamIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class TeamArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyTeamArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    team: Union[bool, 'TeamArgsFromCourtRecursive1']
    participant: Union[bool, 'ParticipantArgsFromCourtRecursive1']


class TeamParticipantIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    team: Union[bool, 'TeamArgsFromCourtRecursive2']
    participant: Union[bool, 'ParticipantArgsFromCourtRecursive2']


class TeamParticipantIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    team: Union[bool, 'TeamArgsFromCourtRecursive3']
    participant: Union[bool, 'ParticipantArgsFromCourtRecursive3']


class TeamParticipantIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    team: Union[bool, 'TeamArgsFromCourtRecursive4']
    participant: Union[bool, 'ParticipantArgsFromCourtRecursive4']


class TeamParticipantIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class TeamParticipantArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyTeamParticipantArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive1']


class CourtIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive2']


class CourtIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive3']


class CourtIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromCourtRecursive4']


class CourtIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class CourtArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyCourtArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromCourt(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive1']
    category: Union[bool, 'CategoryArgsFromCourtRecursive1']
    court: Union[bool, 'CourtArgsFromCourtRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromCourtRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromCourtRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromCourtRecursive1']
    referee: Union[bool, 'UserArgsFromCourtRecursive1']


class MatchIncludeFromCourtRecursive1(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive2']
    category: Union[bool, 'CategoryArgsFromCourtRecursive2']
    court: Union[bool, 'CourtArgsFromCourtRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromCourtRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromCourtRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromCourtRecursive2']
    referee: Union[bool, 'UserArgsFromCourtRecursive2']


class MatchIncludeFromCourtRecursive2(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive3']
    category: Union[bool, 'CategoryArgsFromCourtRecursive3']
    court: Union[bool, 'CourtArgsFromCourtRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromCourtRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromCourtRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromCourtRecursive3']
    referee: Union[bool, 'UserArgsFromCourtRecursive3']


class MatchIncludeFromCourtRecursive3(TypedDict, total=False):
    """Relational arguments for Court"""
    tournament: Union[bool, 'TournamentArgsFromCourtRecursive4']
    category: Union[bool, 'CategoryArgsFromCourtRecursive4']
    court: Union[bool, 'CourtArgsFromCourtRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromCourtRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromCourtRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromCourtRecursive4']
    referee: Union[bool, 'UserArgsFromCourtRecursive4']


class MatchIncludeFromCourtRecursive4(TypedDict, total=False):
    """Relational arguments for Court"""

    

class MatchArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    
    

class FindManyMatchArgsFromCourt(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromCourtRecursive1(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromCourtRecursive2(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromCourtRecursive3(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromCourtRecursive4(TypedDict, total=False):
    """Arguments for Court"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyCourtArgs = FindManyCourtArgsFromCourt
FindFirstCourtArgs = FindManyCourtArgsFromCourt


    

class CourtWhereInput(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    locationNote: Union[None, _str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CourtWhereInputRecursive1', List['CourtWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CourtWhereInputRecursive1']
    OR: List['CourtWhereInputRecursive1']
    NOT: List['CourtWhereInputRecursive1']


class CourtWhereInputRecursive1(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    locationNote: Union[None, _str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CourtWhereInputRecursive2', List['CourtWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CourtWhereInputRecursive2']
    OR: List['CourtWhereInputRecursive2']
    NOT: List['CourtWhereInputRecursive2']


class CourtWhereInputRecursive2(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    locationNote: Union[None, _str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CourtWhereInputRecursive3', List['CourtWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CourtWhereInputRecursive3']
    OR: List['CourtWhereInputRecursive3']
    NOT: List['CourtWhereInputRecursive3']


class CourtWhereInputRecursive3(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    locationNote: Union[None, _str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    matches: 'MatchListRelationFilter'

    # should be noted that AND and NOT should be Union['CourtWhereInputRecursive4', List['CourtWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CourtWhereInputRecursive4']
    OR: List['CourtWhereInputRecursive4']
    NOT: List['CourtWhereInputRecursive4']


class CourtWhereInputRecursive4(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    locationNote: Union[None, _str, 'types.StringFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    matches: 'MatchListRelationFilter'



# aggregate Court types


    

class CourtScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    locationNote: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CourtScalarWhereWithAggregatesInputRecursive1']
    OR: List['CourtScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CourtScalarWhereWithAggregatesInputRecursive1']


class CourtScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    locationNote: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CourtScalarWhereWithAggregatesInputRecursive2']
    OR: List['CourtScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CourtScalarWhereWithAggregatesInputRecursive2']


class CourtScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    locationNote: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CourtScalarWhereWithAggregatesInputRecursive3']
    OR: List['CourtScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CourtScalarWhereWithAggregatesInputRecursive3']


class CourtScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    locationNote: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['CourtScalarWhereWithAggregatesInputRecursive4']
    OR: List['CourtScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CourtScalarWhereWithAggregatesInputRecursive4']


class CourtScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Court arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    locationNote: Union[_str, 'types.StringWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']



class CourtGroupByOutput(TypedDict, total=False):
    id: _int
    name: _str
    locationNote: _str
    tournamentId: _int
    _sum: 'CourtSumAggregateOutput'
    _avg: 'CourtAvgAggregateOutput'
    _min: 'CourtMinAggregateOutput'
    _max: 'CourtMaxAggregateOutput'
    _count: 'CourtCountAggregateOutput'


class CourtAvgAggregateOutput(TypedDict, total=False):
    """Court output for aggregating averages"""
    id: float
    tournamentId: float


class CourtSumAggregateOutput(TypedDict, total=False):
    """Court output for aggregating sums"""
    id: _int
    tournamentId: _int


class CourtScalarAggregateOutput(TypedDict, total=False):
    """Court output including scalar fields"""
    id: _int
    name: _str
    locationNote: _str
    tournamentId: _int


CourtMinAggregateOutput = CourtScalarAggregateOutput
CourtMaxAggregateOutput = CourtScalarAggregateOutput


class CourtMaxAggregateInput(TypedDict, total=False):
    """Court input for aggregating by max"""
    id: bool
    name: bool
    locationNote: bool
    tournamentId: bool


class CourtMinAggregateInput(TypedDict, total=False):
    """Court input for aggregating by min"""
    id: bool
    name: bool
    locationNote: bool
    tournamentId: bool


class CourtNumberAggregateInput(TypedDict, total=False):
    """Court input for aggregating numbers"""
    id: bool
    tournamentId: bool


CourtAvgAggregateInput = CourtNumberAggregateInput
CourtSumAggregateInput = CourtNumberAggregateInput


CourtCountAggregateInput = TypedDict(
    'CourtCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'locationNote': bool,
        'tournamentId': bool,
        '_all': bool,
    },
    total=False,
)

CourtCountAggregateOutput = TypedDict(
    'CourtCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'locationNote': int,
        'tournamentId': int,
        '_all': int,
    },
    total=False,
)


CourtKeys = Literal[
    'id',
    'name',
    'locationNote',
    'tournamentId',
    'tournament',
    'matches',
]
CourtScalarFieldKeys = Literal[
    'id',
    'name',
    'locationNote',
    'tournamentId',
]
CourtScalarFieldKeysT = TypeVar('CourtScalarFieldKeysT', bound=CourtScalarFieldKeys)

CourtRelationalFieldKeys = Literal[
        'tournament',
        'matches',
    ]

# Match types

class MatchOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Match create method"""
    id: _int
    groupCode: Optional[_str]
    scheduledAt: Optional[datetime.datetime]
    startedAt: Optional[datetime.datetime]
    finishedAt: Optional[datetime.datetime]
    status: 'enums.MatchStatus'
    homeScore: Optional[_int]
    awayScore: Optional[_int]
    tournamentId: _int
    tournament: 'TournamentCreateNestedWithoutRelationsInput'
    categoryId: _int
    category: 'CategoryCreateNestedWithoutRelationsInput'
    courtId: Optional[_int]
    court: 'CourtCreateNestedWithoutRelationsInput'
    homeTeamId: _int
    homeTeam: 'TeamCreateNestedWithoutRelationsInput'
    awayTeamId: _int
    awayTeam: 'TeamCreateNestedWithoutRelationsInput'
    winnerTeamId: Optional[_int]
    winnerTeam: 'TeamCreateNestedWithoutRelationsInput'
    refereeId: Optional[_int]
    referee: 'UserCreateNestedWithoutRelationsInput'


class MatchCreateInput(MatchOptionalCreateInput):
    """Required arguments to the Match create method"""
    round: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MatchOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Match create method, without relations"""
    id: _int
    groupCode: Optional[_str]
    scheduledAt: Optional[datetime.datetime]
    startedAt: Optional[datetime.datetime]
    finishedAt: Optional[datetime.datetime]
    status: 'enums.MatchStatus'
    homeScore: Optional[_int]
    awayScore: Optional[_int]
    tournamentId: _int
    categoryId: _int
    courtId: Optional[_int]
    homeTeamId: _int
    awayTeamId: _int
    winnerTeamId: Optional[_int]
    refereeId: Optional[_int]


class MatchCreateWithoutRelationsInput(MatchOptionalCreateWithoutRelationsInput):
    """Required arguments to the Match create method, without relations"""
    round: _int

class MatchConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MatchCreateWithoutRelationsInput'
    where: 'MatchWhereUniqueInput'

class MatchCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MatchCreateWithoutRelationsInput'
    connect: 'MatchWhereUniqueInput'
    connect_or_create: 'MatchConnectOrCreateWithoutRelationsInput'


class MatchCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MatchCreateWithoutRelationsInput', List['MatchCreateWithoutRelationsInput']]
    connect: Union['MatchWhereUniqueInput', List['MatchWhereUniqueInput']]
    connect_or_create: Union['MatchConnectOrCreateWithoutRelationsInput', List['MatchConnectOrCreateWithoutRelationsInput']]

_MatchWhereUnique_id_Input = TypedDict(
    '_MatchWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

MatchWhereUniqueInput = _MatchWhereUnique_id_Input


class MatchUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    round: Union[AtomicIntInput, _int]
    groupCode: Optional[_str]
    scheduledAt: Optional[datetime.datetime]
    startedAt: Optional[datetime.datetime]
    finishedAt: Optional[datetime.datetime]
    status: 'enums.MatchStatus'
    homeScore: Optional[Union[AtomicIntInput, _int]]
    awayScore: Optional[Union[AtomicIntInput, _int]]
    tournament: 'TournamentUpdateOneWithoutRelationsInput'
    category: 'CategoryUpdateOneWithoutRelationsInput'
    court: 'CourtUpdateOneWithoutRelationsInput'
    homeTeam: 'TeamUpdateOneWithoutRelationsInput'
    awayTeam: 'TeamUpdateOneWithoutRelationsInput'
    winnerTeam: 'TeamUpdateOneWithoutRelationsInput'
    referee: 'UserUpdateOneWithoutRelationsInput'


class MatchUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    round: Union[AtomicIntInput, _int]
    groupCode: Optional[_str]
    scheduledAt: Optional[datetime.datetime]
    startedAt: Optional[datetime.datetime]
    finishedAt: Optional[datetime.datetime]
    status: 'enums.MatchStatus'
    homeScore: Optional[Union[AtomicIntInput, _int]]
    awayScore: Optional[Union[AtomicIntInput, _int]]


class MatchUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MatchCreateWithoutRelationsInput']
    connect: List['MatchWhereUniqueInput']
    connect_or_create: List['MatchConnectOrCreateWithoutRelationsInput']
    set: List['MatchWhereUniqueInput']
    disconnect: List['MatchWhereUniqueInput']
    delete: List['MatchWhereUniqueInput']

    # TODO
    # update: List['MatchUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MatchUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MatchScalarWhereInput']
    # upsert: List['MatchUpserteWithWhereUniqueWithoutRelationsInput']


class MatchUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MatchCreateWithoutRelationsInput'
    connect: 'MatchWhereUniqueInput'
    connect_or_create: 'MatchConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MatchUpdateInput'
    # upsert: 'MatchUpsertWithoutRelationsInput'


class MatchUpsertInput(TypedDict):
    create: 'MatchCreateInput'
    update: 'MatchUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Match_id_OrderByInput = TypedDict(
    '_Match_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Match_round_OrderByInput = TypedDict(
    '_Match_round_OrderByInput',
    {
        'round': 'SortOrder',
    },
    total=True
)

_Match_groupCode_OrderByInput = TypedDict(
    '_Match_groupCode_OrderByInput',
    {
        'groupCode': 'SortOrder',
    },
    total=True
)

_Match_scheduledAt_OrderByInput = TypedDict(
    '_Match_scheduledAt_OrderByInput',
    {
        'scheduledAt': 'SortOrder',
    },
    total=True
)

_Match_startedAt_OrderByInput = TypedDict(
    '_Match_startedAt_OrderByInput',
    {
        'startedAt': 'SortOrder',
    },
    total=True
)

_Match_finishedAt_OrderByInput = TypedDict(
    '_Match_finishedAt_OrderByInput',
    {
        'finishedAt': 'SortOrder',
    },
    total=True
)

_Match_status_OrderByInput = TypedDict(
    '_Match_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Match_homeScore_OrderByInput = TypedDict(
    '_Match_homeScore_OrderByInput',
    {
        'homeScore': 'SortOrder',
    },
    total=True
)

_Match_awayScore_OrderByInput = TypedDict(
    '_Match_awayScore_OrderByInput',
    {
        'awayScore': 'SortOrder',
    },
    total=True
)

_Match_tournamentId_OrderByInput = TypedDict(
    '_Match_tournamentId_OrderByInput',
    {
        'tournamentId': 'SortOrder',
    },
    total=True
)

_Match_categoryId_OrderByInput = TypedDict(
    '_Match_categoryId_OrderByInput',
    {
        'categoryId': 'SortOrder',
    },
    total=True
)

_Match_courtId_OrderByInput = TypedDict(
    '_Match_courtId_OrderByInput',
    {
        'courtId': 'SortOrder',
    },
    total=True
)

_Match_homeTeamId_OrderByInput = TypedDict(
    '_Match_homeTeamId_OrderByInput',
    {
        'homeTeamId': 'SortOrder',
    },
    total=True
)

_Match_awayTeamId_OrderByInput = TypedDict(
    '_Match_awayTeamId_OrderByInput',
    {
        'awayTeamId': 'SortOrder',
    },
    total=True
)

_Match_winnerTeamId_OrderByInput = TypedDict(
    '_Match_winnerTeamId_OrderByInput',
    {
        'winnerTeamId': 'SortOrder',
    },
    total=True
)

_Match_refereeId_OrderByInput = TypedDict(
    '_Match_refereeId_OrderByInput',
    {
        'refereeId': 'SortOrder',
    },
    total=True
)

_Match_RelevanceInner = TypedDict(
    '_Match_RelevanceInner',
    {
        'fields': 'List[MatchScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Match_RelevanceOrderByInput = TypedDict(
    '_Match_RelevanceOrderByInput',
    {
        '_relevance': '_Match_RelevanceInner',
    },
    total=True
)

MatchOrderByInput = Union[
    '_Match_id_OrderByInput',
    '_Match_round_OrderByInput',
    '_Match_groupCode_OrderByInput',
    '_Match_scheduledAt_OrderByInput',
    '_Match_startedAt_OrderByInput',
    '_Match_finishedAt_OrderByInput',
    '_Match_status_OrderByInput',
    '_Match_homeScore_OrderByInput',
    '_Match_awayScore_OrderByInput',
    '_Match_tournamentId_OrderByInput',
    '_Match_categoryId_OrderByInput',
    '_Match_courtId_OrderByInput',
    '_Match_homeTeamId_OrderByInput',
    '_Match_awayTeamId_OrderByInput',
    '_Match_winnerTeamId_OrderByInput',
    '_Match_refereeId_OrderByInput',
    '_Match_RelevanceOrderByInput',
]



# recursive Match types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MatchRelationFilter = TypedDict(
    'MatchRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MatchListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MatchInclude(TypedDict, total=False):
    """Match relational arguments"""
    tournament: Union[bool, 'TournamentArgsFromMatch']
    category: Union[bool, 'CategoryArgsFromMatch']
    court: Union[bool, 'CourtArgsFromMatch']
    homeTeam: Union[bool, 'TeamArgsFromMatch']
    awayTeam: Union[bool, 'TeamArgsFromMatch']
    winnerTeam: Union[bool, 'TeamArgsFromMatch']
    referee: Union[bool, 'UserArgsFromMatch']


    

class UserIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromMatchRecursive1']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromMatchRecursive1']


class UserIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromMatchRecursive2']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromMatchRecursive2']


class UserIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromMatchRecursive3']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromMatchRecursive3']


class UserIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    tournamentsCreated: Union[bool, 'FindManyTournamentArgsFromMatchRecursive4']
    matchesRefereed: Union[bool, 'FindManyMatchArgsFromMatchRecursive4']


class UserIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class UserArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyUserArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class TournamentIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    createdBy: Union[bool, 'UserArgsFromMatchRecursive1']
    categories: Union[bool, 'FindManyCategoryArgsFromMatchRecursive1']
    courts: Union[bool, 'FindManyCourtArgsFromMatchRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive1']


class TournamentIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    createdBy: Union[bool, 'UserArgsFromMatchRecursive2']
    categories: Union[bool, 'FindManyCategoryArgsFromMatchRecursive2']
    courts: Union[bool, 'FindManyCourtArgsFromMatchRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive2']


class TournamentIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    createdBy: Union[bool, 'UserArgsFromMatchRecursive3']
    categories: Union[bool, 'FindManyCategoryArgsFromMatchRecursive3']
    courts: Union[bool, 'FindManyCourtArgsFromMatchRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive3']


class TournamentIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    createdBy: Union[bool, 'UserArgsFromMatchRecursive4']
    categories: Union[bool, 'FindManyCategoryArgsFromMatchRecursive4']
    courts: Union[bool, 'FindManyCourtArgsFromMatchRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive4']


class TournamentIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class TournamentArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TournamentIncludeFromTournamentRecursive1'


class TournamentArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TournamentIncludeFromTournamentRecursive2'


class TournamentArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TournamentIncludeFromTournamentRecursive3'


class TournamentArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TournamentIncludeFromTournamentRecursive4'


class TournamentArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyTournamentArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive1'


class FindManyTournamentArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive2'


class FindManyTournamentArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive3'


class FindManyTournamentArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    include: 'TournamentIncludeFromTournamentRecursive4'


class FindManyTournamentArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TournamentOrderByInput', List['TournamentOrderByInput']]
    where: 'TournamentWhereInput'
    cursor: 'TournamentWhereUniqueInput'
    distinct: List['TournamentScalarFieldKeys']
    
    

class CategoryIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive1']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive1']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive1']


class CategoryIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive2']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive2']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive2']


class CategoryIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive3']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive3']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive3']


class CategoryIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive4']
    participants: Union[bool, 'FindManyParticipantArgsFromMatchRecursive4']
    teams: Union[bool, 'FindManyTeamArgsFromMatchRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive4']


class CategoryIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class CategoryArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CategoryIncludeFromCategoryRecursive1'


class CategoryArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CategoryIncludeFromCategoryRecursive2'


class CategoryArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CategoryIncludeFromCategoryRecursive3'


class CategoryArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CategoryIncludeFromCategoryRecursive4'


class CategoryArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyCategoryArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive1'


class FindManyCategoryArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive2'


class FindManyCategoryArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive3'


class FindManyCategoryArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    include: 'CategoryIncludeFromCategoryRecursive4'


class FindManyCategoryArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CategoryOrderByInput', List['CategoryOrderByInput']]
    where: 'CategoryWhereInput'
    cursor: 'CategoryWhereUniqueInput'
    distinct: List['CategoryScalarFieldKeys']
    
    

class ParticipantIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive1']
    category: Union[bool, 'CategoryArgsFromMatchRecursive1']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive1']


class ParticipantIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive2']
    category: Union[bool, 'CategoryArgsFromMatchRecursive2']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive2']


class ParticipantIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive3']
    category: Union[bool, 'CategoryArgsFromMatchRecursive3']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive3']


class ParticipantIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive4']
    category: Union[bool, 'CategoryArgsFromMatchRecursive4']
    teamLinks: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive4']


class ParticipantIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class ParticipantArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ParticipantIncludeFromParticipantRecursive1'


class ParticipantArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ParticipantIncludeFromParticipantRecursive2'


class ParticipantArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ParticipantIncludeFromParticipantRecursive3'


class ParticipantArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'ParticipantIncludeFromParticipantRecursive4'


class ParticipantArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyParticipantArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive1'


class FindManyParticipantArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive2'


class FindManyParticipantArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive3'


class FindManyParticipantArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    include: 'ParticipantIncludeFromParticipantRecursive4'


class FindManyParticipantArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['ParticipantOrderByInput', List['ParticipantOrderByInput']]
    where: 'ParticipantWhereInput'
    cursor: 'ParticipantWhereUniqueInput'
    distinct: List['ParticipantScalarFieldKeys']
    
    

class TeamIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive1']
    category: Union[bool, 'CategoryArgsFromMatchRecursive1']
    players: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive1']
    homeMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive1']
    awayMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive1']
    winnerOf: Union[bool, 'FindManyMatchArgsFromMatchRecursive1']


class TeamIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive2']
    category: Union[bool, 'CategoryArgsFromMatchRecursive2']
    players: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive2']
    homeMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive2']
    awayMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive2']
    winnerOf: Union[bool, 'FindManyMatchArgsFromMatchRecursive2']


class TeamIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive3']
    category: Union[bool, 'CategoryArgsFromMatchRecursive3']
    players: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive3']
    homeMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive3']
    awayMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive3']
    winnerOf: Union[bool, 'FindManyMatchArgsFromMatchRecursive3']


class TeamIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive4']
    category: Union[bool, 'CategoryArgsFromMatchRecursive4']
    players: Union[bool, 'FindManyTeamParticipantArgsFromMatchRecursive4']
    homeMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive4']
    awayMatches: Union[bool, 'FindManyMatchArgsFromMatchRecursive4']
    winnerOf: Union[bool, 'FindManyMatchArgsFromMatchRecursive4']


class TeamIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class TeamArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamIncludeFromTeamRecursive1'


class TeamArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamIncludeFromTeamRecursive2'


class TeamArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamIncludeFromTeamRecursive3'


class TeamArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamIncludeFromTeamRecursive4'


class TeamArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyTeamArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive1'


class FindManyTeamArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive2'


class FindManyTeamArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive3'


class FindManyTeamArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    include: 'TeamIncludeFromTeamRecursive4'


class FindManyTeamArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamOrderByInput', List['TeamOrderByInput']]
    where: 'TeamWhereInput'
    cursor: 'TeamWhereUniqueInput'
    distinct: List['TeamScalarFieldKeys']
    
    

class TeamParticipantIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    team: Union[bool, 'TeamArgsFromMatchRecursive1']
    participant: Union[bool, 'ParticipantArgsFromMatchRecursive1']


class TeamParticipantIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    team: Union[bool, 'TeamArgsFromMatchRecursive2']
    participant: Union[bool, 'ParticipantArgsFromMatchRecursive2']


class TeamParticipantIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    team: Union[bool, 'TeamArgsFromMatchRecursive3']
    participant: Union[bool, 'ParticipantArgsFromMatchRecursive3']


class TeamParticipantIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    team: Union[bool, 'TeamArgsFromMatchRecursive4']
    participant: Union[bool, 'ParticipantArgsFromMatchRecursive4']


class TeamParticipantIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class TeamParticipantArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class TeamParticipantArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class TeamParticipantArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class TeamParticipantArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class TeamParticipantArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyTeamParticipantArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive1'


class FindManyTeamParticipantArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive2'


class FindManyTeamParticipantArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive3'


class FindManyTeamParticipantArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    include: 'TeamParticipantIncludeFromTeamParticipantRecursive4'


class FindManyTeamParticipantArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['TeamParticipantOrderByInput', List['TeamParticipantOrderByInput']]
    where: 'TeamParticipantWhereInput'
    cursor: 'TeamParticipantWhereUniqueInput'
    distinct: List['TeamParticipantScalarFieldKeys']
    
    

class CourtIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive1']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive1']


class CourtIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive2']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive2']


class CourtIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive3']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive3']


class CourtIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive4']
    matches: Union[bool, 'FindManyMatchArgsFromMatchRecursive4']


class CourtIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class CourtArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CourtIncludeFromCourtRecursive1'


class CourtArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CourtIncludeFromCourtRecursive2'


class CourtArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CourtIncludeFromCourtRecursive3'


class CourtArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'CourtIncludeFromCourtRecursive4'


class CourtArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyCourtArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive1'


class FindManyCourtArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive2'


class FindManyCourtArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive3'


class FindManyCourtArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    include: 'CourtIncludeFromCourtRecursive4'


class FindManyCourtArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['CourtOrderByInput', List['CourtOrderByInput']]
    where: 'CourtWhereInput'
    cursor: 'CourtWhereUniqueInput'
    distinct: List['CourtScalarFieldKeys']
    
    

class MatchIncludeFromMatch(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive1']
    category: Union[bool, 'CategoryArgsFromMatchRecursive1']
    court: Union[bool, 'CourtArgsFromMatchRecursive1']
    homeTeam: Union[bool, 'TeamArgsFromMatchRecursive1']
    awayTeam: Union[bool, 'TeamArgsFromMatchRecursive1']
    winnerTeam: Union[bool, 'TeamArgsFromMatchRecursive1']
    referee: Union[bool, 'UserArgsFromMatchRecursive1']


class MatchIncludeFromMatchRecursive1(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive2']
    category: Union[bool, 'CategoryArgsFromMatchRecursive2']
    court: Union[bool, 'CourtArgsFromMatchRecursive2']
    homeTeam: Union[bool, 'TeamArgsFromMatchRecursive2']
    awayTeam: Union[bool, 'TeamArgsFromMatchRecursive2']
    winnerTeam: Union[bool, 'TeamArgsFromMatchRecursive2']
    referee: Union[bool, 'UserArgsFromMatchRecursive2']


class MatchIncludeFromMatchRecursive2(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive3']
    category: Union[bool, 'CategoryArgsFromMatchRecursive3']
    court: Union[bool, 'CourtArgsFromMatchRecursive3']
    homeTeam: Union[bool, 'TeamArgsFromMatchRecursive3']
    awayTeam: Union[bool, 'TeamArgsFromMatchRecursive3']
    winnerTeam: Union[bool, 'TeamArgsFromMatchRecursive3']
    referee: Union[bool, 'UserArgsFromMatchRecursive3']


class MatchIncludeFromMatchRecursive3(TypedDict, total=False):
    """Relational arguments for Match"""
    tournament: Union[bool, 'TournamentArgsFromMatchRecursive4']
    category: Union[bool, 'CategoryArgsFromMatchRecursive4']
    court: Union[bool, 'CourtArgsFromMatchRecursive4']
    homeTeam: Union[bool, 'TeamArgsFromMatchRecursive4']
    awayTeam: Union[bool, 'TeamArgsFromMatchRecursive4']
    winnerTeam: Union[bool, 'TeamArgsFromMatchRecursive4']
    referee: Union[bool, 'UserArgsFromMatchRecursive4']


class MatchIncludeFromMatchRecursive4(TypedDict, total=False):
    """Relational arguments for Match"""

    

class MatchArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    include: 'MatchIncludeFromMatchRecursive1'


class MatchArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    include: 'MatchIncludeFromMatchRecursive2'


class MatchArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    include: 'MatchIncludeFromMatchRecursive3'


class MatchArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    include: 'MatchIncludeFromMatchRecursive4'


class MatchArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    
    

class FindManyMatchArgsFromMatch(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive1'


class FindManyMatchArgsFromMatchRecursive1(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive2'


class FindManyMatchArgsFromMatchRecursive2(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive3'


class FindManyMatchArgsFromMatchRecursive3(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    include: 'MatchIncludeFromMatchRecursive4'


class FindManyMatchArgsFromMatchRecursive4(TypedDict, total=False):
    """Arguments for Match"""
    take: int
    skip: int
    order_by: Union['MatchOrderByInput', List['MatchOrderByInput']]
    where: 'MatchWhereInput'
    cursor: 'MatchWhereUniqueInput'
    distinct: List['MatchScalarFieldKeys']
    


FindManyMatchArgs = FindManyMatchArgsFromMatch
FindFirstMatchArgs = FindManyMatchArgsFromMatch


    

class MatchWhereInput(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    round: Union[_int, 'types.IntFilter']
    groupCode: Union[None, _str, 'types.StringFilter']
    scheduledAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[None, _int, 'types.IntFilter']
    awayScore: Union[None, _int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    courtId: Union[None, _int, 'types.IntFilter']
    court: 'CourtRelationFilter'
    homeTeamId: Union[_int, 'types.IntFilter']
    homeTeam: 'TeamRelationFilter'
    awayTeamId: Union[_int, 'types.IntFilter']
    awayTeam: 'TeamRelationFilter'
    winnerTeamId: Union[None, _int, 'types.IntFilter']
    winnerTeam: 'TeamRelationFilter'
    refereeId: Union[None, _int, 'types.IntFilter']
    referee: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['MatchWhereInputRecursive1', List['MatchWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MatchWhereInputRecursive1']
    OR: List['MatchWhereInputRecursive1']
    NOT: List['MatchWhereInputRecursive1']


class MatchWhereInputRecursive1(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    round: Union[_int, 'types.IntFilter']
    groupCode: Union[None, _str, 'types.StringFilter']
    scheduledAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[None, _int, 'types.IntFilter']
    awayScore: Union[None, _int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    courtId: Union[None, _int, 'types.IntFilter']
    court: 'CourtRelationFilter'
    homeTeamId: Union[_int, 'types.IntFilter']
    homeTeam: 'TeamRelationFilter'
    awayTeamId: Union[_int, 'types.IntFilter']
    awayTeam: 'TeamRelationFilter'
    winnerTeamId: Union[None, _int, 'types.IntFilter']
    winnerTeam: 'TeamRelationFilter'
    refereeId: Union[None, _int, 'types.IntFilter']
    referee: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['MatchWhereInputRecursive2', List['MatchWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MatchWhereInputRecursive2']
    OR: List['MatchWhereInputRecursive2']
    NOT: List['MatchWhereInputRecursive2']


class MatchWhereInputRecursive2(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    round: Union[_int, 'types.IntFilter']
    groupCode: Union[None, _str, 'types.StringFilter']
    scheduledAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[None, _int, 'types.IntFilter']
    awayScore: Union[None, _int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    courtId: Union[None, _int, 'types.IntFilter']
    court: 'CourtRelationFilter'
    homeTeamId: Union[_int, 'types.IntFilter']
    homeTeam: 'TeamRelationFilter'
    awayTeamId: Union[_int, 'types.IntFilter']
    awayTeam: 'TeamRelationFilter'
    winnerTeamId: Union[None, _int, 'types.IntFilter']
    winnerTeam: 'TeamRelationFilter'
    refereeId: Union[None, _int, 'types.IntFilter']
    referee: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['MatchWhereInputRecursive3', List['MatchWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MatchWhereInputRecursive3']
    OR: List['MatchWhereInputRecursive3']
    NOT: List['MatchWhereInputRecursive3']


class MatchWhereInputRecursive3(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    round: Union[_int, 'types.IntFilter']
    groupCode: Union[None, _str, 'types.StringFilter']
    scheduledAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[None, _int, 'types.IntFilter']
    awayScore: Union[None, _int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    courtId: Union[None, _int, 'types.IntFilter']
    court: 'CourtRelationFilter'
    homeTeamId: Union[_int, 'types.IntFilter']
    homeTeam: 'TeamRelationFilter'
    awayTeamId: Union[_int, 'types.IntFilter']
    awayTeam: 'TeamRelationFilter'
    winnerTeamId: Union[None, _int, 'types.IntFilter']
    winnerTeam: 'TeamRelationFilter'
    refereeId: Union[None, _int, 'types.IntFilter']
    referee: 'UserRelationFilter'

    # should be noted that AND and NOT should be Union['MatchWhereInputRecursive4', List['MatchWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MatchWhereInputRecursive4']
    OR: List['MatchWhereInputRecursive4']
    NOT: List['MatchWhereInputRecursive4']


class MatchWhereInputRecursive4(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    round: Union[_int, 'types.IntFilter']
    groupCode: Union[None, _str, 'types.StringFilter']
    scheduledAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[None, _int, 'types.IntFilter']
    awayScore: Union[None, _int, 'types.IntFilter']
    tournamentId: Union[_int, 'types.IntFilter']
    tournament: 'TournamentRelationFilter'
    categoryId: Union[_int, 'types.IntFilter']
    category: 'CategoryRelationFilter'
    courtId: Union[None, _int, 'types.IntFilter']
    court: 'CourtRelationFilter'
    homeTeamId: Union[_int, 'types.IntFilter']
    homeTeam: 'TeamRelationFilter'
    awayTeamId: Union[_int, 'types.IntFilter']
    awayTeam: 'TeamRelationFilter'
    winnerTeamId: Union[None, _int, 'types.IntFilter']
    winnerTeam: 'TeamRelationFilter'
    refereeId: Union[None, _int, 'types.IntFilter']
    referee: 'UserRelationFilter'



# aggregate Match types


    

class MatchScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    round: Union[_int, 'types.IntWithAggregatesFilter']
    groupCode: Union[_str, 'types.StringWithAggregatesFilter']
    scheduledAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[_int, 'types.IntWithAggregatesFilter']
    awayScore: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']
    courtId: Union[_int, 'types.IntWithAggregatesFilter']
    homeTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    awayTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    winnerTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    refereeId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MatchScalarWhereWithAggregatesInputRecursive1']
    OR: List['MatchScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MatchScalarWhereWithAggregatesInputRecursive1']


class MatchScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    round: Union[_int, 'types.IntWithAggregatesFilter']
    groupCode: Union[_str, 'types.StringWithAggregatesFilter']
    scheduledAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[_int, 'types.IntWithAggregatesFilter']
    awayScore: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']
    courtId: Union[_int, 'types.IntWithAggregatesFilter']
    homeTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    awayTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    winnerTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    refereeId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MatchScalarWhereWithAggregatesInputRecursive2']
    OR: List['MatchScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MatchScalarWhereWithAggregatesInputRecursive2']


class MatchScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    round: Union[_int, 'types.IntWithAggregatesFilter']
    groupCode: Union[_str, 'types.StringWithAggregatesFilter']
    scheduledAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[_int, 'types.IntWithAggregatesFilter']
    awayScore: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']
    courtId: Union[_int, 'types.IntWithAggregatesFilter']
    homeTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    awayTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    winnerTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    refereeId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MatchScalarWhereWithAggregatesInputRecursive3']
    OR: List['MatchScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MatchScalarWhereWithAggregatesInputRecursive3']


class MatchScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    round: Union[_int, 'types.IntWithAggregatesFilter']
    groupCode: Union[_str, 'types.StringWithAggregatesFilter']
    scheduledAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[_int, 'types.IntWithAggregatesFilter']
    awayScore: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']
    courtId: Union[_int, 'types.IntWithAggregatesFilter']
    homeTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    awayTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    winnerTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    refereeId: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MatchScalarWhereWithAggregatesInputRecursive4']
    OR: List['MatchScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MatchScalarWhereWithAggregatesInputRecursive4']


class MatchScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Match arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    round: Union[_int, 'types.IntWithAggregatesFilter']
    groupCode: Union[_str, 'types.StringWithAggregatesFilter']
    scheduledAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    status: 'enums.MatchStatus'
    homeScore: Union[_int, 'types.IntWithAggregatesFilter']
    awayScore: Union[_int, 'types.IntWithAggregatesFilter']
    tournamentId: Union[_int, 'types.IntWithAggregatesFilter']
    categoryId: Union[_int, 'types.IntWithAggregatesFilter']
    courtId: Union[_int, 'types.IntWithAggregatesFilter']
    homeTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    awayTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    winnerTeamId: Union[_int, 'types.IntWithAggregatesFilter']
    refereeId: Union[_int, 'types.IntWithAggregatesFilter']



class MatchGroupByOutput(TypedDict, total=False):
    id: _int
    round: _int
    groupCode: _str
    scheduledAt: datetime.datetime
    startedAt: datetime.datetime
    finishedAt: datetime.datetime
    status: 'enums.MatchStatus'
    homeScore: _int
    awayScore: _int
    tournamentId: _int
    categoryId: _int
    courtId: _int
    homeTeamId: _int
    awayTeamId: _int
    winnerTeamId: _int
    refereeId: _int
    _sum: 'MatchSumAggregateOutput'
    _avg: 'MatchAvgAggregateOutput'
    _min: 'MatchMinAggregateOutput'
    _max: 'MatchMaxAggregateOutput'
    _count: 'MatchCountAggregateOutput'


class MatchAvgAggregateOutput(TypedDict, total=False):
    """Match output for aggregating averages"""
    id: float
    round: float
    homeScore: float
    awayScore: float
    tournamentId: float
    categoryId: float
    courtId: float
    homeTeamId: float
    awayTeamId: float
    winnerTeamId: float
    refereeId: float


class MatchSumAggregateOutput(TypedDict, total=False):
    """Match output for aggregating sums"""
    id: _int
    round: _int
    homeScore: _int
    awayScore: _int
    tournamentId: _int
    categoryId: _int
    courtId: _int
    homeTeamId: _int
    awayTeamId: _int
    winnerTeamId: _int
    refereeId: _int


class MatchScalarAggregateOutput(TypedDict, total=False):
    """Match output including scalar fields"""
    id: _int
    round: _int
    groupCode: _str
    scheduledAt: datetime.datetime
    startedAt: datetime.datetime
    finishedAt: datetime.datetime
    status: 'enums.MatchStatus'
    homeScore: _int
    awayScore: _int
    tournamentId: _int
    categoryId: _int
    courtId: _int
    homeTeamId: _int
    awayTeamId: _int
    winnerTeamId: _int
    refereeId: _int


MatchMinAggregateOutput = MatchScalarAggregateOutput
MatchMaxAggregateOutput = MatchScalarAggregateOutput


class MatchMaxAggregateInput(TypedDict, total=False):
    """Match input for aggregating by max"""
    id: bool
    round: bool
    groupCode: bool
    scheduledAt: bool
    startedAt: bool
    finishedAt: bool
    status: bool
    homeScore: bool
    awayScore: bool
    tournamentId: bool
    categoryId: bool
    courtId: bool
    homeTeamId: bool
    awayTeamId: bool
    winnerTeamId: bool
    refereeId: bool


class MatchMinAggregateInput(TypedDict, total=False):
    """Match input for aggregating by min"""
    id: bool
    round: bool
    groupCode: bool
    scheduledAt: bool
    startedAt: bool
    finishedAt: bool
    status: bool
    homeScore: bool
    awayScore: bool
    tournamentId: bool
    categoryId: bool
    courtId: bool
    homeTeamId: bool
    awayTeamId: bool
    winnerTeamId: bool
    refereeId: bool


class MatchNumberAggregateInput(TypedDict, total=False):
    """Match input for aggregating numbers"""
    id: bool
    round: bool
    homeScore: bool
    awayScore: bool
    tournamentId: bool
    categoryId: bool
    courtId: bool
    homeTeamId: bool
    awayTeamId: bool
    winnerTeamId: bool
    refereeId: bool


MatchAvgAggregateInput = MatchNumberAggregateInput
MatchSumAggregateInput = MatchNumberAggregateInput


MatchCountAggregateInput = TypedDict(
    'MatchCountAggregateInput',
    {
        'id': bool,
        'round': bool,
        'groupCode': bool,
        'scheduledAt': bool,
        'startedAt': bool,
        'finishedAt': bool,
        'status': bool,
        'homeScore': bool,
        'awayScore': bool,
        'tournamentId': bool,
        'categoryId': bool,
        'courtId': bool,
        'homeTeamId': bool,
        'awayTeamId': bool,
        'winnerTeamId': bool,
        'refereeId': bool,
        '_all': bool,
    },
    total=False,
)

MatchCountAggregateOutput = TypedDict(
    'MatchCountAggregateOutput',
    {
        'id': int,
        'round': int,
        'groupCode': int,
        'scheduledAt': int,
        'startedAt': int,
        'finishedAt': int,
        'status': int,
        'homeScore': int,
        'awayScore': int,
        'tournamentId': int,
        'categoryId': int,
        'courtId': int,
        'homeTeamId': int,
        'awayTeamId': int,
        'winnerTeamId': int,
        'refereeId': int,
        '_all': int,
    },
    total=False,
)


MatchKeys = Literal[
    'id',
    'round',
    'groupCode',
    'scheduledAt',
    'startedAt',
    'finishedAt',
    'status',
    'homeScore',
    'awayScore',
    'tournamentId',
    'tournament',
    'categoryId',
    'category',
    'courtId',
    'court',
    'homeTeamId',
    'homeTeam',
    'awayTeamId',
    'awayTeam',
    'winnerTeamId',
    'winnerTeam',
    'refereeId',
    'referee',
]
MatchScalarFieldKeys = Literal[
    'id',
    'round',
    'groupCode',
    'scheduledAt',
    'startedAt',
    'finishedAt',
    'status',
    'homeScore',
    'awayScore',
    'tournamentId',
    'categoryId',
    'courtId',
    'homeTeamId',
    'awayTeamId',
    'winnerTeamId',
    'refereeId',
]
MatchScalarFieldKeysT = TypeVar('MatchScalarFieldKeysT', bound=MatchScalarFieldKeys)

MatchRelationalFieldKeys = Literal[
        'tournament',
        'category',
        'court',
        'homeTeam',
        'awayTeam',
        'winnerTeam',
        'referee',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields